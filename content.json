{"meta":{"title":"qiwenming","subtitle":null,"description":null,"author":"qiwenming","url":"http://qiwenming.github.io"},"pages":[{"title":"categories","date":"2018-01-12T17:21:40.000Z","updated":"2018-01-12T17:21:40.106Z","comments":true,"path":"categories/index-1.html","permalink":"http://qiwenming.github.io/categories/index-1.html","excerpt":"","text":""},{"title":"tags","date":"2018-01-12T16:38:22.000Z","updated":"2018-01-12T17:14:32.627Z","comments":true,"path":"tags/index.html","permalink":"http://qiwenming.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-01-11T16:33:15.000Z","updated":"2018-01-12T17:22:18.979Z","comments":true,"path":"categories/index.html","permalink":"http://qiwenming.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"SSH与SSM学习之hibernate25——批量抓取","slug":"hibernate/25","date":"2017-11-19T13:52:16.000Z","updated":"2018-01-18T13:51:53.591Z","comments":false,"path":"hibernate/25/2017/11/19/","link":"","permalink":"http://qiwenming.github.io/hibernate/25/2017/11/19/","excerpt":"","text":"SSH与SSM学习之hibernate25——批量抓取一、添加数据我们现在需要添加数据，所以的配置使用默认的配置。 12345678910111213141516171819202122/** * 添加测试数据 */@Testpublic void addData()&#123; Session session = HibernateUtils.openSession(); Transaction t = session.beginTransaction(); //------------------------------------------- for (int i = 0; i &lt; 5; i++) &#123; Company c = new Company(); c.setName(&quot;新公司_&quot;+i); Employee emp = new Employee(); emp.setName(&quot;wiming_&quot;+i); emp.setCompany(c); session.save(c); session.save(emp); &#125; //------------------------------------------- t.commit(); session.close();&#125; 现在我们的有5个公司，每个公司有1个员工。 二、测试代码12345678910111213141516171819/** * 批量抓取 */@Testpublic void test()&#123; Session session = HibernateUtils.openSession(); Transaction t = session.beginTransaction(); //------------------------------------------- Query query = session.createQuery(&quot;from Company&quot;); List&lt;Company&gt; list = query.list(); System.out.println(&quot;---------one--------&quot;); for (Company c : list) &#123; System.out.println(c.getEmps()); System.out.println(&quot;---------------&quot;); &#125; //------------------------------------------- t.commit(); session.close();&#125; 三、分析我们知道我们的表中有5个公司。上面的测试代码，在默认情况下，除了查询到公司的数据以外，还会查询5次。这是因为我们的员工的数据是使用懒加载的（默认的）。也就是说每循环一次，就会去查询一次数据。这样感觉效率很低下。因此有一个属性 batch-size，它的意思就是，一次抓取多少条数据。那上面的例子举例，如果batch-size=3，那么意思就是说第一次循环的时候，查询了Company的3个对象的集合数据，第一次循环以后，第一、二、三的集合数据就查询出来，不用再去查了。到了第四的时候，再去查询3条，由于数据只有两条了，所以最后只查询2个对象的集合。这样我查询集合其实只是2次而已。 三、默认情况下的查询123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172Hibernate: select company0_.id as id1_0_, company0_.name as name2_0_ from tb_company company0_---------one--------Hibernate: select emps0_.com_id as com_id3_1_0_, emps0_.em_id as em_id1_1_0_, emps0_.em_id as em_id1_1_1_, emps0_.name as name2_1_1_, emps0_.com_id as com_id3_1_1_ from tb_employee emps0_ where emps0_.com_id=?[Employee&#123;em_id=1, name=&apos;wiming_0&apos;&#125;]---------------Hibernate: select emps0_.com_id as com_id3_1_0_, emps0_.em_id as em_id1_1_0_, emps0_.em_id as em_id1_1_1_, emps0_.name as name2_1_1_, emps0_.com_id as com_id3_1_1_ from tb_employee emps0_ where emps0_.com_id=?[Employee&#123;em_id=2, name=&apos;wiming_1&apos;&#125;]---------------Hibernate: select emps0_.com_id as com_id3_1_0_, emps0_.em_id as em_id1_1_0_, emps0_.em_id as em_id1_1_1_, emps0_.name as name2_1_1_, emps0_.com_id as com_id3_1_1_ from tb_employee emps0_ where emps0_.com_id=?[Employee&#123;em_id=3, name=&apos;wiming_2&apos;&#125;]---------------Hibernate: select emps0_.com_id as com_id3_1_0_, emps0_.em_id as em_id1_1_0_, emps0_.em_id as em_id1_1_1_, emps0_.name as name2_1_1_, emps0_.com_id as com_id3_1_1_ from tb_employee emps0_ where emps0_.com_id=?[Employee&#123;em_id=4, name=&apos;wiming_3&apos;&#125;]---------------Hibernate: select emps0_.com_id as com_id3_1_0_, emps0_.em_id as em_id1_1_0_, emps0_.em_id as em_id1_1_1_, emps0_.name as name2_1_1_, emps0_.com_id as com_id3_1_1_ from tb_employee emps0_ where emps0_.com_id=?[Employee&#123;em_id=5, name=&apos;wiming_4&apos;&#125;]--------------- 四、Company.hbm.xml添加batch-size12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package=&quot;com.qwm.hibernate03.domain&quot; &gt; &lt;class name=&quot;Company&quot; table=&quot;tb_company&quot;&gt; &lt;id name=&quot;id&quot;&gt; &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;name&quot; &gt;&lt;/property&gt; &lt;!-- batch-size: 抓取集合的数量为3. 抓取客户的集合时,一次抓取几个公司的员工集合. --&gt; &lt;set name=&quot;emps&quot; batch-size=&quot;3&quot;&gt; &lt;key column=&quot;com_id&quot;&gt;&lt;/key&gt; &lt;one-to-many class=&quot;Employee&quot;&gt;&lt;/one-to-many&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 五、批量抓取12345678910111213141516171819202122232425262728293031323334353637383940414243Hibernate: select company0_.id as id1_0_, company0_.name as name2_0_ from tb_company company0_---------one--------Hibernate: select emps0_.com_id as com_id3_1_1_, emps0_.em_id as em_id1_1_1_, emps0_.em_id as em_id1_1_0_, emps0_.name as name2_1_0_, emps0_.com_id as com_id3_1_0_ from tb_employee emps0_ where emps0_.com_id in ( ?, ?, ? )[Employee&#123;em_id=1, name=&apos;wiming_0&apos;&#125;]---------------[Employee&#123;em_id=2, name=&apos;wiming_1&apos;&#125;]---------------[Employee&#123;em_id=3, name=&apos;wiming_2&apos;&#125;]---------------Hibernate: select emps0_.com_id as com_id3_1_1_, emps0_.em_id as em_id1_1_1_, emps0_.em_id as em_id1_1_0_, emps0_.name as name2_1_0_, emps0_.com_id as com_id3_1_0_ from tb_employee emps0_ where emps0_.com_id in ( ?, ? )[Employee&#123;em_id=4, name=&apos;wiming_3&apos;&#125;]---------------[Employee&#123;em_id=5, name=&apos;wiming_4&apos;&#125;]---------------","categories":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/categories/ssm/"},{"name":"hibernate","slug":"ssm/hibernate","permalink":"http://qiwenming.github.io/categories/ssm/hibernate/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/tags/ssm/"},{"name":"hibernate","slug":"hibernate","permalink":"http://qiwenming.github.io/tags/hibernate/"}]},{"title":"SSH与SSM学习之hibernate24——关联级别加载策略之属性关联加载策略","slug":"hibernate/24","date":"2017-11-19T13:52:15.000Z","updated":"2018-01-18T13:51:53.589Z","comments":false,"path":"hibernate/24/2017/11/19/","link":"","permalink":"http://qiwenming.github.io/hibernate/24/2017/11/19/","excerpt":"","text":"SSH与SSM学习之hibernate24——关联级别加载策略之属性关联加载策略一、说明现在我们说的是 属性关联加载策略。和之前的 SSH与SSM学习之hibernate23——关联级别加载策略之集合关联加载策略 区别是 集合关联说的是：通过一个对象，获取到与它关联的集合数据，例如：通过公司，获取到员工（多个），这是一个集合 属性关联说的是：通过一个对象，获取到与它关联的对象数据，例如：通过员工，获取到公司（一个），这是一个属性 属性关联使用到的是 lazy和fetch 二、laze和fetch的取值lazy叫做懒加载或者延迟加载，取值如下 取值 说明 proxy: 由相关类的类级别加载策略决定（true或者false） false: 立即加载 fetch（抓取策略），决定加载策略.使用什么类型的sql语句加载集合数据。取值如下 取值 说明 select (默认值): 单表查询加载 join: 使用多表查询加载集合 下面我们分为二者的属性值两两配对（笛卡尔积）测试 第一行代表，lazy的取值 第一列代表，fetch的取值 proxy=tue proxy=false false select select,true select,false select,false join join,ture join,false join,false 我们知道 proxy 由相关类的类加载策略决定的，当proxy=false的时候，和 属性关联的lazy为false是一样的。 所以我们只需要验证下面的四种情况 proxy=tue proxy=false select select,true select,false join join,ture join,false 三、Company.hbm.xml配置1234567.....&lt;hibernate-mapping package=&quot;com.qwm.hibernate03.domain&quot; &gt; &lt;!--测试中所说的 proxy的值为其实就是下面这个lazy的值--&gt; &lt;class name=&quot;Company&quot; table=&quot;tb_company&quot; lazy=&quot;true&quot;&gt; ..... &lt;/class&gt;&lt;/hibernate-mapping&gt; 四、Employee.hbm.xml123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package=&quot;com.qwm.hibernate03.domain&quot; &gt; &lt;class name=&quot;Employee&quot; table=&quot;tb_employee&quot; &gt; &lt;id name=&quot;em_id&quot; &gt; &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;name&quot; &gt;&lt;/property&gt; &lt;!-- fetch 决定加载的sql语句 select: 使用单表查询 join : 多表查询 lazy 决定加载时机 false: 立即加载 proxy: 由Company的类级别加载策略决定. --&gt; &lt;many-to-one name=&quot;company&quot; column=&quot;com_id&quot; class=&quot;Company&quot; fetch=&quot;select&quot; lazy=&quot;proxy&quot;/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 五、测试代码1234567891011121314151617181920/** * 所有的测试代码都是一样的 */@Testpublic void test1()&#123; Session session = HibernateUtils.openSession(); Transaction t = session.beginTransaction(); //---------------------------------------------- //获取到员工 Employee employee = session.get(Employee.class,1L); System.out.println(&quot;-------------one--------------&quot;); //获取到公司 Company c = employee.getCompany(); System.out.println(&quot;-------------two--------------&quot;); //使用公司 System.out.println(c); //---------------------------------------------- t.commit(); session.close();&#125; 六、fetch为select, proxy对应的对象取值为true测试1234567891011121314151617181920Hibernate: select employee0_.em_id as em_id1_1_0_, employee0_.name as name2_1_0_, employee0_.com_id as com_id3_1_0_ from tb_employee employee0_ where employee0_.em_id=?-------------one---------------------------two--------------Hibernate: select company0_.id as id1_0_0_, company0_.name as name2_0_0_ from tb_company company0_ where company0_.id=?Company&#123;id=1, name=&apos;百鸟公司&apos;&#125; fetch为select, proxy对应的对象取值为true。单表查询，使用了懒加载，属性只有使用的时候采取查询。 七、fetch为select, proxy对应的对象取值为false测试1234567891011121314151617181920Hibernate: select employee0_.em_id as em_id1_1_0_, employee0_.name as name2_1_0_, employee0_.com_id as com_id3_1_0_ from tb_employee employee0_ where employee0_.em_id=?Hibernate: select company0_.id as id1_0_0_, company0_.name as name2_0_0_ from tb_company company0_ where company0_.id=?-------------one---------------------------two--------------Company&#123;id=1, name=&apos;百鸟公司&apos;&#125; fetch为select, proxy对应的对象取值为false。单表查询，直接查询数据。使用的时候，直接使用。 八、fetch为join测试fetch为join的时候，lazy失效。使用多表查询，直接加载 1234567891011121314151617Hibernate: select employee0_.em_id as em_id1_1_0_, employee0_.name as name2_1_0_, employee0_.com_id as com_id3_1_0_, company1_.id as id1_0_1_, company1_.name as name2_0_1_ from tb_employee employee0_ left outer join tb_company company1_ on employee0_.com_id=company1_.id where employee0_.em_id=?-------------one---------------------------two--------------Company&#123;id=1, name=&apos;百鸟公司&apos;&#125; 九、结论结论:为了提高效率.fetch的选择上应选择select. lazy的取值应选择 true. 全部使用默认值. 十、no-session问题解决: 扩大session的作用范围.我们使用懒加载的策略，那么查询完成以后，session就关闭了。这个时候我们的使用到了属性，这个时候由于是懒加载，所以回去查询数据，然而session已经关闭了，那么就会抛出 no-session 的异常。 对于这个问题的解决，就是扩大session的作用范围。打开session和关闭session 都放到 Filter中。 image","categories":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/categories/ssm/"},{"name":"hibernate","slug":"ssm/hibernate","permalink":"http://qiwenming.github.io/categories/ssm/hibernate/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/tags/ssm/"},{"name":"hibernate","slug":"hibernate","permalink":"http://qiwenming.github.io/tags/hibernate/"}]},{"title":"SSH与SSM学习之hibernate23——关联级别加载策略之集合关联加载策略","slug":"hibernate/23","date":"2017-11-19T13:52:14.000Z","updated":"2018-01-18T13:51:53.588Z","comments":false,"path":"hibernate/23/2017/11/19/","link":"","permalink":"http://qiwenming.github.io/hibernate/23/2017/11/19/","excerpt":"","text":"SSH与SSM学习之hibernate23——关联级别加载策略之集合关联加载策略一、说明关联级别加载策略，其实就是在关联查询中，使用lazy和fetch的策略。 比如说我们查询一个公司，然后通过公司查询到员工这就是关联，反之亦然。 这个和我们前面的 类级别加载策略 使用上的区别是： 我们的类级别加载策略使用在 中 然后我们的关联级别是用在设置关联的地方，比如一对多我们用在中。 二、lazy和fetch的取值lazy叫做懒加载或者延迟加载，取值如下 取值 说明 true(默认值): 延迟加载,懒加载 false: 立即加载 extra: 极其懒惰 fetch（抓取策略），决定加载策略.使用什么类型的sql语句加载集合数据。取值如下 取值 说明 select (默认值): 单表查询加载 join: 使用多表查询加载集合 subselect: 使用子查询加载集合 下面我们分为二者的属性值两两配对（笛卡尔积）测试 第一行代表，lazy的取值 第一列代表，fetch的取值 true false extra select select,true select,false select,extra join join,ture join,false join,extra subselect subselect,true subselect,true subselect,extra 三、配置文件 Company.hbm.xml测试的时候，修改的就是 中的 lazy和fetch 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package=&quot;com.qwm.hibernate03.domain&quot; &gt; &lt;class name=&quot;Company&quot; table=&quot;tb_company&quot;&gt; &lt;id name=&quot;id&quot;&gt; &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;name&quot; &gt;&lt;/property&gt; &lt;!-- lazy属性: 决定是否延迟加载 true(默认值): 延迟加载,懒加载 false: 立即加载 extra: 极其懒惰 fetch属性: 决定加载策略.使用什么类型的sql语句加载集合数据 select(默认值): 单表查询加载 join: 使用多表查询加载集合 subselect:使用子查询加载集合 --&gt; &lt;!--测试的时候，修改的就是下面 lazy和fetch的值--&gt; &lt;set name=&quot;emps&quot; lazy=&quot;true&quot; fetch=&quot;select&quot;&gt; &lt;key column=&quot;com_id&quot;&gt;&lt;/key&gt; &lt;one-to-many class=&quot;Employee&quot;&gt;&lt;/one-to-many&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 四、fetch为select , lazy为 true | false | extra 测试4.1 测试代码123456789101112131415161718192021222324252627/** * 关联级测试，集合关联 * fetch:select * lazy:true 使用时才加载集合数据 * lazy:false 立即记载集合数据 * lazy:extra 极其懒惰.与懒加载效果基本一致. 如果只获得集合的size.只查询集合的size(count语句) * 这里测试的是，通过公司查询公司的员工 */@Testpublic void test3()&#123; Session session = HibernateUtils.openSession(); Transaction t = session.beginTransaction(); //------------------------------ //获取到公司 Company c = session.get(Company.class,1L); System.out.println(&quot;------------第一个分割线-------------&quot;); //获取这个公司的员工（关联） Set&lt;Employee&gt; emps = c.getEmps(); System.out.println(&quot;------------第二个分割线-------------&quot;); System.out.println(emps.size()); System.out.println(&quot;------------第三个分割线-------------&quot;); System.out.println(emps); //------------------------------ t.commit(); session.close();&#125; 4.2 fetch为select , lazy为 true 打印结果123456789101112131415161718192021222324Hibernate: select company0_.id as id1_0_0_, company0_.name as name2_0_0_ from tb_company company0_ where company0_.id=?------------第一个分割线-------------------------第二个分割线-------------Hibernate: select emps0_.com_id as com_id3_1_0_, emps0_.em_id as em_id1_1_0_, emps0_.em_id as em_id1_1_1_, emps0_.name as name2_1_1_, emps0_.com_id as com_id3_1_1_ from tb_employee emps0_ where emps0_.com_id=?2------------第三个分割线-------------[Employee&#123;em_id=2, name=&apos;周小龙&apos;&#125;, Employee&#123;em_id=1, name=&apos;李晓飞&apos;&#125;] 我们可以看到 fetch为select , lazy为 true 的时候，我们查询公司的时候，只查询了公司的信息，没有查询员工的信息，只有使用员工的集合的时候，采取查询。使用了懒加载。 4.3 fetch为select , lazy为 false 打印结果123456789101112131415161718192021222324Hibernate: select company0_.id as id1_0_0_, company0_.name as name2_0_0_ from tb_company company0_ where company0_.id=?Hibernate: select emps0_.com_id as com_id3_1_0_, emps0_.em_id as em_id1_1_0_, emps0_.em_id as em_id1_1_1_, emps0_.name as name2_1_1_, emps0_.com_id as com_id3_1_1_ from tb_employee emps0_ where emps0_.com_id=?------------第一个分割线-------------------------第二个分割线-------------2------------第三个分割线-------------[Employee&#123;em_id=2, name=&apos;周小龙&apos;&#125;, Employee&#123;em_id=1, name=&apos;李晓飞&apos;&#125;] fetch为select , lazy为 false ，不使用懒加载，会直接加载数据。 4.4 fetch为select , lazy为 extra 打印结果12345678910111213141516171819202122232425262728293031Hibernate: select company0_.id as id1_0_0_, company0_.name as name2_0_0_ from tb_company company0_ where company0_.id=?------------第一个分割线-------------------------第二个分割线-------------Hibernate: select count(em_id) from tb_employee where com_id =?2------------第三个分割线-------------Hibernate: select emps0_.com_id as com_id3_1_0_, emps0_.em_id as em_id1_1_0_, emps0_.em_id as em_id1_1_1_, emps0_.name as name2_1_1_, emps0_.com_id as com_id3_1_1_ from tb_employee emps0_ where emps0_.com_id=?[Employee&#123;em_id=2, name=&apos;周小龙&apos;&#125;, Employee&#123;em_id=1, name=&apos;李晓飞&apos;&#125;] fetch为select , lazy为 extra，极其懒惰.与懒加载效果基本一致. 如果只获得集合的size.只查询集合的size(count语句) 五、fetch为join , lazy为 true | false | extra 测试5.1 测试代码12345678910111213141516171819202122232425/** * 关联级测试，集合关联 * fetch:join * lazy:true|false|extra 失效，都是立即查询 * 这里测试的是，通过公司查询公司的员工 */@Testpublic void test4()&#123; Session session = HibernateUtils.openSession(); Transaction t = session.beginTransaction(); //------------------------------ //获取到公司 Company c = session.get(Company.class,1L); System.out.println(&quot;------------第一个分割线-------------&quot;); //获取这个公司的员工（关联） Set&lt;Employee&gt; emps = c.getEmps(); System.out.println(&quot;------------第二个分割线-------------&quot;); System.out.println(emps.size()); System.out.println(&quot;------------第三个分割线-------------&quot;); System.out.println(emps); //------------------------------ t.commit(); session.close();&#125; 5.2 fetch为join , true | false | extra 打印结果123456789101112131415161718192021Hibernate: select company0_.id as id1_0_0_, company0_.name as name2_0_0_, emps1_.com_id as com_id3_1_1_, emps1_.em_id as em_id1_1_1_, emps1_.em_id as em_id1_1_2_, emps1_.name as name2_1_2_, emps1_.com_id as com_id3_1_2_ from tb_company company0_ left outer join tb_employee emps1_ on company0_.id=emps1_.com_id where company0_.id=?------------第一个分割线-------------------------第二个分割线-------------2------------第三个分割线-------------[Employee&#123;em_id=1, name=&apos;李晓飞&apos;&#125;, Employee&#123;em_id=2, name=&apos;周小龙&apos;&#125;] fetch使用join的情况下，lazy失效，都是直接加载数据。 六、fetch为join , lazy为 true | false | extra 测试6.1 测试代码12 6.2 fetch为subselect , lazy为true 打印结果1234567891011121314151617181920212223242526272829Hibernate: select company0_.id as id1_0_, company0_.name as name2_0_ from tb_company company0_------------第一个分割线-------------------------第二个分割线-------------Company&#123;id=1, name=&apos;百鸟公司&apos;&#125;------------第三个分割线-------------Hibernate: select emps0_.com_id as com_id3_1_1_, emps0_.em_id as em_id1_1_1_, emps0_.em_id as em_id1_1_0_, emps0_.name as name2_1_0_, emps0_.com_id as com_id3_1_0_ from tb_employee emps0_ where emps0_.com_id in ( select company0_.id from tb_company company0_ )2------------第四个分割线-------------[Employee&#123;em_id=1, name=&apos;李晓飞&apos;&#125;, Employee&#123;em_id=2, name=&apos;周小龙&apos;&#125;] fetch为subselect , lazy为true ，首先会查询出公司的信息，不会查询员工信息。使用的员工集合的时候，会使用子查询查询出员工信息。 6.3 fetch为subselect , lazy为false 打印结果1234567891011121314151617181920212223242526272829Hibernate: select company0_.id as id1_0_, company0_.name as name2_0_ from tb_company company0_Hibernate: select emps0_.com_id as com_id3_1_1_, emps0_.em_id as em_id1_1_1_, emps0_.em_id as em_id1_1_0_, emps0_.name as name2_1_0_, emps0_.com_id as com_id3_1_0_ from tb_employee emps0_ where emps0_.com_id in ( select company0_.id from tb_company company0_ )------------第一个分割线-------------------------第二个分割线-------------Company&#123;id=1, name=&apos;百鸟公司&apos;&#125;------------第三个分割线-------------2------------第四个分割线-------------[Employee&#123;em_id=1, name=&apos;李晓飞&apos;&#125;, Employee&#123;em_id=2, name=&apos;周小龙&apos;&#125;] fetch为subselect , lazy为false 。直接加载。首先使用查询出公司信息，然后通过子查询，查询出员工信息。 6.4 fetch为subselect , lazy为extra 打印结果123456789101112131415161718192021222324252627282930313233343536Hibernate: select company0_.id as id1_0_, company0_.name as name2_0_ from tb_company company0_------------第一个分割线-------------------------第二个分割线-------------Company&#123;id=1, name=&apos;百鸟公司&apos;&#125;------------第三个分割线-------------Hibernate: select count(em_id) from tb_employee where com_id =?2------------第四个分割线-------------Hibernate: select emps0_.com_id as com_id3_1_1_, emps0_.em_id as em_id1_1_1_, emps0_.em_id as em_id1_1_0_, emps0_.name as name2_1_0_, emps0_.com_id as com_id3_1_0_ from tb_employee emps0_ where emps0_.com_id in ( select company0_.id from tb_company company0_ )[Employee&#123;em_id=1, name=&apos;李晓飞&apos;&#125;, Employee&#123;em_id=2, name=&apos;周小龙&apos;&#125;] fetch为subselect , lazy为extra ，首先会查询出公司的信息，不会查询员工信息。使用的员工集合的时候，如果只是使用到size(),那么会使用count() 查询出个数。使用到员工集合的时候，会使用子查询查询出员工信息。","categories":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/categories/ssm/"},{"name":"hibernate","slug":"ssm/hibernate","permalink":"http://qiwenming.github.io/categories/ssm/hibernate/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/tags/ssm/"},{"name":"hibernate","slug":"hibernate","permalink":"http://qiwenming.github.io/tags/hibernate/"}]},{"title":"SSH与SSM学习之hibernate22——类级别加载策略","slug":"hibernate/22","date":"2017-11-19T13:52:13.000Z","updated":"2018-01-18T13:51:53.586Z","comments":false,"path":"hibernate/22/2017/11/19/","link":"","permalink":"http://qiwenming.github.io/hibernate/22/2017/11/19/","excerpt":"","text":"SSH与SSM学习之hibernate22——类级别加载策略一、说明我们这里说的类级别加载策略，其实就是懒加载(lazy)。主要我们就是来看看使用懒加载和不适用懒加载查询有什么区别。 二、实体类与配置创建2.1 说明我们这里使用的关系是公司和员工一对多的关系。公司使用Company,员工使用 Employee。 2.2 Company.java 实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.qwm.hibernate03.domain;import java.util.HashSet;import java.util.Set;/** * @author：qiwenming * @date：2017/9/21 0021 0:12 * @description： * 公司实体 */public class Company &#123; private Long id; private String name; //一对多 private Set&lt;Employee&gt; emps = new HashSet&lt;&gt;(); public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Set&lt;Employee&gt; getEmps() &#123; return emps; &#125; public void setEmps(Set&lt;Employee&gt; emps) &#123; this.emps = emps; &#125; @Override public String toString() &#123; return &quot;Company&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&apos;&quot; + name + &apos;\\&apos;&apos; + &apos;&#125;&apos;; &#125;&#125; 2.3 Company.hbm.xml12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package=&quot;com.qwm.hibernate03.domain&quot; &gt; &lt;class name=&quot;Company&quot; table=&quot;tb_company&quot; lazy=&quot;true&quot;&gt; &lt;id name=&quot;id&quot;&gt; &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;name&quot; &gt;&lt;/property&gt; &lt;!-- 集合,一对多关系,在配置文件中配置 --&gt; &lt;!-- name属性:集合属性名 column属性: 外键列名 class属性: 与我关联的对象完整类名 --&gt; &lt;set name=&quot;emps&quot;&gt; &lt;key column=&quot;com_id&quot;&gt;&lt;/key&gt; &lt;one-to-many class=&quot;Employee&quot;&gt;&lt;/one-to-many&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 2.4 Employee.java 实体类123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.qwm.hibernate03.domain;/** * @author：qiwenming * @date：2017/9/21 0021 0:14 * @description： * y员工 */public class Employee &#123; private Long em_id; private String name; private Company company; public Long getEm_id() &#123; return em_id; &#125; public void setEm_id(Long em_id) &#123; this.em_id = em_id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Company getCompany() &#123; return company; &#125; public void setCompany(Company company) &#123; this.company = company; &#125; @Override public String toString() &#123; return &quot;Employee&#123;&quot; + &quot;em_id=&quot; + em_id + &quot;, name=&apos;&quot; + name + &apos;\\&apos;&apos; + &apos;&#125;&apos;; &#125;&#125; 2.5 Employee.hbm.xml1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package=&quot;com.qwm.hibernate03.domain&quot; &gt; &lt;class name=&quot;Employee&quot; table=&quot;tb_employee&quot; &gt; &lt;id name=&quot;em_id&quot; &gt; &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;name&quot; &gt;&lt;/property&gt; &lt;!-- 多对一 --&gt; &lt;!-- name属性:引用属性名 column属性: 外键列名 class属性: 与我关联的对象完整类名 --&gt; &lt;many-to-one name=&quot;company&quot; column=&quot;com_id&quot; class=&quot;Company&quot;/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 2.6 添加测试数据的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 用户添加测试数据而已 */@Testpublic void test()&#123; Session session = HibernateUtils.openSession(); Transaction t = session.beginTransaction(); //------------------------------------------- Company c1 = new Company(); c1.setName(&quot;百鸟公司&quot;); Company c2 = new Company(); c2.setName(&quot;新合伙公司&quot;); Employee e11 = new Employee(); e11.setName(&quot;李晓飞&quot;); e11.setCompany(c1); Employee e12 = new Employee(); e12.setName(&quot;周小龙&quot;); e12.setCompany(c1); Employee e21 = new Employee(); e21.setName(&quot;张大波&quot;); e21.setCompany(c2); Employee e22 = new Employee(); e22.setName(&quot;吴人用&quot;); e22.setCompany(c2); Employee e23 = new Employee(); e23.setName(&quot;晓峰&quot;); e23.setCompany(c2); //保存到数据库 session.save(c1); session.save(c2); session.save(e11); session.save(e12); session.save(e21); session.save(e22); session.save(e23); //--------------------------------------------- t.commit(); session.close();&#125; 三、get测试3.1 实例代码123456789101112131415/*** get方法 : 立即加载.执行方法时立即发送sql语句查询结果*/@Testpublic void test1()&#123; Session session = HibernateUtils.openSession(); Transaction t = session.beginTransaction(); //------------------------------------------- Company c = session.get(Company.class,1L); System.out.println(&quot;-------------我是分割线--------------&quot;); System.out.println(c); //--------------------------------------------- t.commit(); session.close();&#125; 3.2 结果12345678910Hibernate: select company0_.id as id1_0_0_, company0_.name as name2_0_0_ from tb_company company0_ where company0_.id=?-------------我是分割线--------------Company&#123;id=1, name=&apos;百鸟公司&apos;&#125; 3.3 结论1get方法 : 立即加载.执行方法时立即发送sql语句查询结果 四、使用懒加载测试默认就是使用懒加载，或者修改我们 Company.hbm.xml ，添加我们懒加载属性（lazy） 123456.......&lt;class name=&quot;Company&quot; table=&quot;tb_company&quot; lazy=&quot;true&quot;&gt; .......&lt;/class&gt;....... 4.1 实例代码12345678910111213141516171819/** * load方法(默认):是在执行时,不发送任何sql语句.返回一个对象.使用该对象时,才执行查询. * 延迟加载: 仅仅获得没有使用.不会查询.在使用时才进行查询. * 是否对类进行延迟加载: 可以通过在class元素上配置lazy属性来控制. * lazy:true 加载时,不查询.使用时才查询b * lazy:false 加载时立即查询. */@Testpublic void test2()&#123; Session session = HibernateUtils.openSession(); Transaction t = session.beginTransaction(); //------------------------------------------- Company c = session.load(Company.class,1L); System.out.println(&quot;-------------我是分割线--------------&quot;); System.out.println(c); //--------------------------------------------- t.commit(); session.close();&#125; 4.2 结果12345678910-------------我是分割线--------------Hibernate: select company0_.id as id1_0_0_, company0_.name as name2_0_0_ from tb_company company0_ where company0_.id=?Company&#123;id=1, name=&apos;百鸟公司&apos;&#125; 4.3 结论12load方法(默认):是在执行时,不发送任何sql语句.返回一个对象.使用该对象时,才执行查询.返回的其实是一个代理对象 五、不使用懒加载测试测试代码和 四 是一样的 5.1 修改配置文件123456.......&lt;class name=&quot;Company&quot; table=&quot;tb_company&quot; lazy=&quot;false&quot;&gt; .......&lt;/class&gt;....... 5.2 结果12345678910Hibernate: select company0_.id as id1_0_0_, company0_.name as name2_0_0_ from tb_company company0_ where company0_.id=?-------------我是分割线--------------Company&#123;id=1, name=&apos;百鸟公司&apos;&#125; 5.3 结论123lazy:false 加载时立即查询.和get方法是一样的返回的是一个我们查询的对象，不是代理对象","categories":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/categories/ssm/"},{"name":"hibernate","slug":"ssm/hibernate","permalink":"http://qiwenming.github.io/categories/ssm/hibernate/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/tags/ssm/"},{"name":"hibernate","slug":"hibernate","permalink":"http://qiwenming.github.io/tags/hibernate/"}]},{"title":"SSH与SSM学习之hibernate21——离线查询","slug":"hibernate/21","date":"2017-11-19T13:52:12.000Z","updated":"2018-01-18T13:51:53.585Z","comments":false,"path":"hibernate/21/2017/11/19/","link":"","permalink":"http://qiwenming.github.io/hibernate/21/2017/11/19/","excerpt":"","text":"SSH与SSM学习之hibernate21——离线查询一、离线查询说明我们在使用查询的时候，都是Service通过传递参数调用Dao相应的查询方法。这样有个问题就是我们的查询方法都是固定的。比如我们通过id查询用户，那么就只能通过id查询用户，不能再通过其他方式查询。这样这个方法写的方法就比较多啦。那么我们想要是实现的就是，Dao 内部只做有一个简单的查询，Service等来指定查询的方法等这样的方式怎么做呢？这就是我们要使用的离线查询了（DetachedCriteria）。 二、非离线查询和离线查询示意图非离线查询 离线查询 三、代码实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.qwm.hibernate03.c_dc;import com.qwm.hibernate03.domain.Customer;import com.qwm.hibernate03.utils.HibernateUtils;import org.hibernate.Criteria;import org.hibernate.Session;import org.hibernate.Transaction;import org.hibernate.criterion.DetachedCriteria;import org.hibernate.criterion.Restrictions;import org.junit.Test;import java.util.List;/** * @author：qiwenming * @date：2017/9/20 0020 23:28 * @description： * 离线查询实例 */public class Demo &#123; @Test public void test1()&#123; //代表service/web层过来的 DetachedCriteria dc = DetachedCriteria.forClass(Customer.class); dc.add(Restrictions.eq(&quot;id&quot;,1L)); //查询 query(dc); &#125; /** * 查询方法 * @param dc */ public void query(DetachedCriteria dc)&#123; Session session = HibernateUtils.openSession(); Transaction t = session.beginTransaction(); Criteria c = dc.getExecutableCriteria(session); List list = c.list(); System.out.println(list); t.commit(); session.close(); &#125;&#125; 四、结果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051Hibernate: alter table cst_linkman add constraint FKh9yp1nql5227xxcopuxqx2e7q foreign key (lkm_cust_id) references cst_customer (cust_id)Hibernate: alter table sys_user_role add constraint FKhh52n8vd4ny9ff4x9fb8v65qx foreign key (role_id) references sys_role (role_id)Hibernate: alter table sys_user_role add constraint FKb40xxfch70f5qnyfw8yme1n1s foreign key (user_id) references sys_user (user_id)Hibernate: select this_.cust_id as cust_id1_0_0_, this_.cust_name as cust_nam2_0_0_, this_.cust_source as cust_sou3_0_0_, this_.cust_industry as cust_ind4_0_0_, this_.cust_level as cust_lev5_0_0_, this_.cust_linkman as cust_lin6_0_0_, this_.cust_phone as cust_pho7_0_0_, this_.cust_mobile as cust_mob8_0_0_ from cst_customer this_ where this_.cust_id=?Hibernate: select linkmens0_.lkm_cust_id as lkm_cus10_1_0_, linkmens0_.lkm_id as lkm_id1_1_0_, linkmens0_.lkm_id as lkm_id1_1_1_, linkmens0_.lkm_gender as lkm_gend2_1_1_, linkmens0_.lkm_name as lkm_name3_1_1_, linkmens0_.lkm_phone as lkm_phon4_1_1_, linkmens0_.lkm_email as lkm_emai5_1_1_, linkmens0_.lkm_qq as lkm_qq6_1_1_, linkmens0_.lkm_mobile as lkm_mobi7_1_1_, linkmens0_.lkm_memo as lkm_memo8_1_1_, linkmens0_.lkm_position as lkm_posi9_1_1_, linkmens0_.lkm_cust_id as lkm_cus10_1_1_ from cst_linkman linkmens0_ where linkmens0_.lkm_cust_id=?[Customer&#123;cust_id=1, cust_name=&apos;吊毛公司&apos;, cust_source=&apos;null&apos;, cust_industry=&apos;null&apos;, cust_level=&apos;null&apos;, cust_linkman=&apos;null&apos;, cust_phone=&apos;null&apos;, cust_mobile=&apos;null&apos;, linkMens=[com.qwm.hibernate03.domain.LinkMan@6034e75d, com.qwm.hibernate03.domain.LinkMan@5e63cad]&#125;]","categories":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/categories/ssm/"},{"name":"hibernate","slug":"ssm/hibernate","permalink":"http://qiwenming.github.io/categories/ssm/hibernate/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/tags/ssm/"},{"name":"hibernate","slug":"hibernate","permalink":"http://qiwenming.github.io/tags/hibernate/"}]},{"title":"SSH与SSM学习之hibernate20——多对多操作","slug":"hibernate/20","date":"2017-11-19T13:52:11.000Z","updated":"2018-01-18T13:51:53.584Z","comments":false,"path":"hibernate/20/2017/11/19/","link":"","permalink":"http://qiwenming.github.io/hibernate/20/2017/11/19/","excerpt":"","text":"SSH与SSM学习之hibernate20——多对多操作一、说明关于多对多的关系可以查看 SSH与SSM学习之hibernate16——表与表的三种关系。 这里我们涉及到的是 用户（员工）与角色之间的多对多的关系。 二、 用户（员工）实体2.1 User.java123456789101112131415161718** * @author：qiwenming * @date：2017/9/19 0019 20:57 * @description： * 用户类 */public class User &#123; private Long user_id; private String user_code; private String user_name; private String user_password; private Character user_state; //表达多对多关系 private Set&lt;Role&gt; roles = new HashSet&lt;&gt;(); ....省略了get/set方法...&#125; 2.2 User.hbm.xml1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package=&quot;com.qwm.hibernate03.domain&quot; &gt; &lt;class name=&quot;User&quot; table=&quot;sys_user&quot; &gt; &lt;id name=&quot;user_id&quot; &gt; &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;user_code&quot; &gt;&lt;/property&gt; &lt;property name=&quot;user_name&quot; &gt;&lt;/property&gt; &lt;property name=&quot;user_password&quot; &gt;&lt;/property&gt; &lt;property name=&quot;user_state&quot; &gt;&lt;/property&gt; &lt;!-- 多对多关系表达 --&gt; &lt;!-- name: 集合属性名 table: 配置中间表名 key |-column:外键,别人引用&quot;我&quot;的外键列名 class: 我与哪个类是多对多关系 column:外键.我引用比人的外键列名 --&gt; &lt;set name=&quot;roles&quot; table=&quot;sys_user_role&quot;&gt; &lt;!----&gt; &lt;key column=&quot;user_id&quot;&gt;&lt;/key&gt; &lt;many-to-many class=&quot;Role&quot; column=&quot;role_id&quot;&gt;&lt;/many-to-many&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 三、角色实体3.1 Role.java12345678910public class Role &#123; private Long role_id; private String role_name; private String role_memo; //表达多对对关系 private Set&lt;User&gt; users = new HashSet&lt;&gt;(); ....省略了get/set方法...&#125; 3.2 Role.hbm.xml123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package=&quot;com.qwm.hibernate03.domain&quot; &gt; &lt;class name=&quot;Role&quot; table=&quot;sys_role&quot; &gt; &lt;id name=&quot;role_id&quot; &gt; &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;role_name&quot; &gt;&lt;/property&gt; &lt;property name=&quot;role_memo&quot; &gt;&lt;/property&gt; &lt;!-- 多对多关系表达 --&gt; &lt;!-- name: 集合属性名 table: 配置中间表名 key |-column:外键,别人引用&quot;我&quot;的外键列名 class: 我与哪个类是多对多关系 column:外键.我引用比人的外键列名 --&gt; &lt;set name=&quot;users&quot; table=&quot;sys_user_role&quot; inverse=&quot;true&quot;&gt; &lt;key column=&quot;role_id&quot;&gt;&lt;/key&gt; &lt;many-to-many class=&quot;User&quot; column=&quot;user_id&quot;&gt;&lt;/many-to-many&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 四、保存用户以及角色4.1 产生的问题以及解决注意： 这里我们保存用户与角色的数据的时候，需要注意，二者默认都是维护着关系的，就会导致二者都会相互之间添加到维护他们两者之间关系的表中，这样就会产生主键冲突，导致无法数据添加失败。 解决方式有两种： 第一种 我们在添加数据关系的时候，只添加一方的关系，不添添加另一方的关系 如：12345678910 //3.3表达关系 user1.getRoles().add(role1); user1.getRoles().add(role2); user2.getRoles().add(role1); user2.getRoles().add(role2);// role1.getUsers().add(user1);// role1.getUsers().add(user2);// role2.getUsers().add(user1);// role2.getUsers().add(user2); 或者 12345678910 //3.3表达关系// user1.getRoles().add(role1);// user1.getRoles().add(role2);// user2.getRoles().add(role1);// user2.getRoles().add(role2); role1.getUsers().add(user1); role1.getUsers().add(user2); role2.getUsers().add(user1); role2.getUsers().add(user2); 第二种 这种方式就是配置一方放弃维护关系，可以配置到 User 中，也可以配置到 Role中， 如 如果是 Role.hbm.xml123456....&lt;set name=&quot;users&quot; table=&quot;sys_user_role&quot; inverse=&quot;true&quot;&gt; &lt;key column=&quot;role_id&quot;&gt;&lt;/key&gt; &lt;many-to-many class=&quot;User&quot; column=&quot;user_id&quot;&gt;&lt;/many-to-many&gt;&lt;/set&gt;... 或者 如果是 User.hbm.xml 1234567......&lt;set name=&quot;roles&quot; table=&quot;sys_user_role&quot; inverse=&quot;true&quot;&gt; &lt;!----&gt; &lt;key column=&quot;user_id&quot;&gt;&lt;/key&gt; &lt;many-to-many class=&quot;Role&quot; column=&quot;role_id&quot;&gt;&lt;/many-to-many&gt;&lt;/set&gt;...... 下面的例子中，我们采用的是配置文件中 Role放弃维护关系，就是上面我们的完整配置 4.2 代码实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 保存用户以及角色 */@Testpublic void test1()&#123; //1.创建session Session session = HibernateUtils.openSession(); //2.开启事务 Transaction t = session.beginTransaction(); //=================================== //3.操作 //3.1创建两个用户 User user1 = new User(); user1.setUser_name(&quot;高晓明&quot;); User user2 = new User(); user2.setUser_name(&quot;李志锋&quot;) ; //3.2创建两角色 Role role1 = new Role(); role1.setRole_name(&quot;保安&quot;); Role role2 = new Role(); role2.setRole_name(&quot;清洁工&quot;); //3.3表达关系 user1.getRoles().add(role1); user1.getRoles().add(role2); user2.getRoles().add(role1); user2.getRoles().add(role2); role1.getUsers().add(user1); role1.getUsers().add(user2); role2.getUsers().add(user1); role2.getUsers().add(user2); //3.4数据持久化 session.save(user1); session.save(user2); session.save(role1); session.save(role2); //=================================== //4.提交事务 t.commit(); //5.关闭资源 session.close();&#125; 4.3 结果用户表 这里写图片描述 角色表 这里写图片描述 用户-角色表 这里写图片描述 五、为用户添加角色5.1 问题说明我们为用户保存角色的时候，有两种方式处理 第一种：我们自己保存角色 例如 12user.getRoles().add(role);session.save(role); 第二种：再我们的user.hbm.xml中配置级联保存 例如12345&lt;set name=&quot;roles&quot; table=&quot;sys_user_role&quot; cascade=&quot;save-update&quot;&gt; &lt;!----&gt; &lt;key column=&quot;user_id&quot;&gt;&lt;/key&gt; &lt;many-to-many class=&quot;Role&quot; column=&quot;role_id&quot;&gt;&lt;/many-to-many&gt;&lt;/set&gt; 这里我们使用的是第一种方式 5.2 示例代码1234567891011121314151617181920212223242526272829/** * 为用户添加角色 * 我们来实现为 “高晓峰”添加一个“部门经理”的角色 */@Testpublic void test2()&#123; //1.创建session Session session = HibernateUtils.openSession(); //2.开启事务 Transaction t = session.beginTransaction(); //=================================== //3.操作 //3.1 得到高晓峰这个用户 User user = session.get(User.class,1L); //3.2 创建“部门经理”这个角色 Role role = new Role(); role.setRole_name(&quot;部门经理&quot;); //3.3 给高晓峰添加“部门经理”这个角色 //这里不用调用保存的方法，保存user,因为user是持久化对象 user.getRoles().add(role);// session.save(role); //=================================== //4.提交事务 t.commit(); //5.关闭资源 session.close();&#125; 5.3 结果 这里写图片描述 六、为用户删除角色6.1 示例代码1234567891011121314151617181920212223242526272829/** * 为用户删除角色 * 我们来实现为 “高晓峰”删除“清洁工”和“保安”的角色 */@Testpublic void test3()&#123; //1.创建session Session session = HibernateUtils.openSession(); //2.开启事务 Transaction t = session.beginTransaction(); //=================================== //3.操作 //3.1获取到用户 //3.2获取到“清洁工”这个角色 //3.3获取到“保安”这个角色 //3.4从用户的角色集合中删除“保安”和“清洁工” User user = session.get(User.class,1L); Role role1 = session.get(Role.class,1L); Role role2 = session.get(Role.class,2L); //user是持久化对象那个，所以不用调用保存的方法 user.getRoles().remove(role1); user.getRoles().remove(role2); //=================================== //4.提交事务 t.commit(); //5.关闭资源 session.close();&#125; 6.2 结果 这里写图片描述","categories":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/categories/ssm/"},{"name":"hibernate","slug":"ssm/hibernate","permalink":"http://qiwenming.github.io/categories/ssm/hibernate/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/tags/ssm/"},{"name":"hibernate","slug":"hibernate","permalink":"http://qiwenming.github.io/tags/hibernate/"}]},{"title":"SSH与SSM学习之hibernate19——多对一一对多关系维护","slug":"hibernate/19","date":"2017-11-19T13:52:10.000Z","updated":"2018-01-18T13:51:53.581Z","comments":false,"path":"hibernate/19/2017/11/19/","link":"","permalink":"http://qiwenming.github.io/hibernate/19/2017/11/19/","excerpt":"","text":"SSH与SSM学习之hibernate19——多对一一对多关系维护一、SQL语句多余了？使用我们之前的代码12345678910111213141516171819202122232425262728293031323334353637/** * 保存客户 以及客户 下的联系人 */@Testpublic void test1()&#123; //1.获取session Session session = HibernateUtils.openSession(); //2.开启事务 Transaction t = session.beginTransaction(); //3.操作 Customer c = new Customer(); c.setCust_name(&quot;吊毛公司&quot;); LinkMan lm1 = new LinkMan(); lm1.setLkm_name(&quot;李吊毛&quot;); LinkMan lm2 = new LinkMan(); lm2.setLkm_name(&quot;高小飞&quot;); //表达一对多,客户下有多个联系人 c.getLinkMens().add(lm1); c.getLinkMens().add(lm2); //表达多对一,联系人属于哪个客户 lm1.setCustomer(c); lm2.setCustomer(c); session.save(c); session.save(lm1); session.save(lm2); //4.提交事务 t.commit(); //5.关闭资源 session.close();&#125; 添加数据的时候，我们发现，我们直插入三条数据，但是却有5个sql语句。 1234567891011121314151617181920212223242526272829303132333435Hibernate: insert into cst_customer (cust_name, cust_source, cust_industry, cust_level, cust_linkman, cust_phone, cust_mobile) values (?, ?, ?, ?, ?, ?, ?)Hibernate: insert into cst_linkman (lkm_gender, lkm_name, lkm_phone, lkm_email, lkm_qq, lkm_mobile, lkm_memo, lkm_position, lkm_cust_id) values (?, ?, ?, ?, ?, ?, ?, ?, ?)Hibernate: insert into cst_linkman (lkm_gender, lkm_name, lkm_phone, lkm_email, lkm_qq, lkm_mobile, lkm_memo, lkm_position, lkm_cust_id) values (?, ?, ?, ?, ?, ?, ?, ?, ?)Hibernate: update cst_linkman set lkm_cust_id=? where lkm_id=?Hibernate: update cst_linkman set lkm_cust_id=? where lkm_id=? 前面的3个SQL是插入数据的，这个无可厚非。那么后面的两个SQL呢？它又是用来干嘛的呢？其实这个我看到是用来更新 联系人表 的外键的，这个外键在插入联系人的时候已经维护过了。所以不可能是联系人表搞得鬼，只可能是 客户表 搞得鬼了。 二、inverse 配置关系是否维护12345678&lt;!-- inverse属性: 配置关系是否维护. true: customer不维护关系 false(默认值): customer维护关系 inverse属性: 性能优化.提高关系维护的性能. 原则: 无论怎么放弃,总有一方必须要维护关系. 一对多关系中: 一的一方放弃.也只能一的一方放弃.多的一方不能放弃.--&gt; 三、配置客户表在客户表中 我们配置不维护 关系 123456789101112131415161718192021222324252627282930&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package=&quot;com.qwm.hibernate03.domain&quot; &gt; &lt;class name=&quot;Customer&quot; table=&quot;cst_customer&quot; &gt; &lt;id name=&quot;cust_id&quot; &gt; &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;cust_name&quot; column=&quot;cust_name&quot; &gt;&lt;/property&gt; &lt;property name=&quot;cust_source&quot; column=&quot;cust_source&quot; &gt;&lt;/property&gt; &lt;property name=&quot;cust_industry&quot; column=&quot;cust_industry&quot; &gt;&lt;/property&gt; &lt;property name=&quot;cust_level&quot; column=&quot;cust_level&quot; &gt;&lt;/property&gt; &lt;property name=&quot;cust_linkman&quot; column=&quot;cust_linkman&quot; &gt;&lt;/property&gt; &lt;property name=&quot;cust_phone&quot; column=&quot;cust_phone&quot; &gt;&lt;/property&gt; &lt;property name=&quot;cust_mobile&quot; column=&quot;cust_mobile&quot; &gt;&lt;/property&gt; &lt;!-- inverse属性: 配置关系是否维护. true: customer不维护关系 false(默认值): customer维护关系 inverse属性: 性能优化.提高关系维护的性能. 原则: 无论怎么放弃,总有一方必须要维护关系. 一对多关系中: 一的一方放弃.也只能一的一方放弃.多的一方不能放弃. --&gt; &lt;set name=&quot;linkMens&quot; inverse=&quot;true&quot;&gt; &lt;key column=&quot;lkm_cust_id&quot;&gt;&lt;/key&gt; &lt;one-to-many class=&quot;LinkMan&quot;&gt;&lt;/one-to-many&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 再次运行上面的代码，得到如下结果 123456789101112131415161718192021Hibernate: insert into cst_customer (cust_name, cust_source, cust_industry, cust_level, cust_linkman, cust_phone, cust_mobile) values (?, ?, ?, ?, ?, ?, ?)Hibernate: insert into cst_linkman (lkm_gender, lkm_name, lkm_phone, lkm_email, lkm_qq, lkm_mobile, lkm_memo, lkm_position, lkm_cust_id) values (?, ?, ?, ?, ?, ?, ?, ?, ?)Hibernate: insert into cst_linkman (lkm_gender, lkm_name, lkm_phone, lkm_email, lkm_qq, lkm_mobile, lkm_memo, lkm_position, lkm_cust_id) values (?, ?, ?, ?, ?, ?, ?, ?, ?) 四、测试的方法可以出去不必要的代码如果客户放弃维护与联系人的关系. 维护关系的代码可以省略 所以上面的测试代码可以去除客户维护联系人的代码。 123456789101112131415161718192021222324252627282930313233343536373839/** * 保存客户 以及客户 下的联系人 */@Testpublic void test1()&#123; //1.获取session Session session = HibernateUtils.openSession(); //2.开启事务 Transaction t = session.beginTransaction(); //3.操作 Customer c = new Customer(); c.setCust_name(&quot;吊毛公司&quot;); LinkMan lm1 = new LinkMan(); lm1.setLkm_name(&quot;李吊毛&quot;); LinkMan lm2 = new LinkMan(); lm2.setLkm_name(&quot;高小飞&quot;); //表达一对多,客户下有多个联系人 //表达一对多,客户下有多个联系人. // 如果客户放弃维护与联系人的关系. 维护关系的代码可以省略// c.getLinkMens().add(lm1);// c.getLinkMens().add(lm2); //表达多对一,联系人属于哪个客户 lm1.setCustomer(c); lm2.setCustomer(c); session.save(c); session.save(lm1); session.save(lm2); //4.提交事务 t.commit(); //5.关闭资源 session.close(); &#125; 五、删除删除的时候需要注意，由于我们的客户表和联系人表是关联的。所以我们有两种方式删除。 把联系人中的客户设置为空，然后可以删除客户表中对应的客户了（可以使用我们的级联） 1234&lt;set name=&quot;linkMens&quot; inverse=&quot;true&quot; cascade=&quot;delete&quot; &gt; &lt;key column=&quot;lkm_cust_id&quot; &gt;&lt;/key&gt; &lt;one-to-many class=&quot;LinkMan&quot; /&gt;&lt;/set&gt; 让客户表维护与联系人之间的关系，这样删除的时候就把对应的联系的外设置为空了。 1234&lt;set name=&quot;linkMens&quot; inverse=&quot;false&quot; &gt; &lt;key column=&quot;lkm_cust_id&quot; &gt;&lt;/key&gt; &lt;one-to-many class=&quot;LinkMan&quot; /&gt;&lt;/set&gt;","categories":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/categories/ssm/"},{"name":"hibernate","slug":"ssm/hibernate","permalink":"http://qiwenming.github.io/categories/ssm/hibernate/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/tags/ssm/"},{"name":"hibernate","slug":"hibernate","permalink":"http://qiwenming.github.io/tags/hibernate/"}]},{"title":"SSH与SSM学习之hibernate18——多对一一对多级联操作","slug":"hibernate/18","date":"2017-11-19T13:52:09.000Z","updated":"2018-01-18T13:51:53.579Z","comments":false,"path":"hibernate/18/2017/11/19/","link":"","permalink":"http://qiwenming.github.io/hibernate/18/2017/11/19/","excerpt":"","text":"SSH与SSM学习之hibernate18——多对一一对多级联操作一、有简便的操作吗？前面我们创建一个客户，两个联系人，我们保存的时候，需要三个保存 如： 123session.save(c);session.save(lm1);session.save(lm2); 那么有没有我们只要保存 客户，就可实现上面三个数据都保存了呢？也就是使用 1session.save(c); 就是实现了上面的三行代码的功能？当然是能的，我们需要使用 级联来操作 二、级联说明123456789 级联操作:cascade save-update: 级联保存更新 delete:级联删除 all:save-update+delete 级联操作: 简化操作. 三、保存客户 以及客户 下的联系人首先我们应该想到，现在我们是保存客户，然后保存客户下的联系人。也是说，实际上我调用的只是保存客户的方法。那么联系人是级联上去。那么我们的级联就应该添加到 客户的配置中。 注意：我们在测试的时候，删除之前创建的表 3.1 Customer.hbm.xml我们使用的级联是 save-update 也可以使用 all 123456789101112131415161718192021222324252627282930&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package=&quot;com.qwm.hibernate03.domain&quot; &gt; &lt;class name=&quot;Customer&quot; table=&quot;cst_customer&quot; &gt; &lt;id name=&quot;cust_id&quot; &gt; &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;cust_name&quot; column=&quot;cust_name&quot; &gt;&lt;/property&gt; &lt;property name=&quot;cust_source&quot; column=&quot;cust_source&quot; &gt;&lt;/property&gt; &lt;property name=&quot;cust_industry&quot; column=&quot;cust_industry&quot; &gt;&lt;/property&gt; &lt;property name=&quot;cust_level&quot; column=&quot;cust_level&quot; &gt;&lt;/property&gt; &lt;property name=&quot;cust_linkman&quot; column=&quot;cust_linkman&quot; &gt;&lt;/property&gt; &lt;property name=&quot;cust_phone&quot; column=&quot;cust_phone&quot; &gt;&lt;/property&gt; &lt;property name=&quot;cust_mobile&quot; column=&quot;cust_mobile&quot; &gt;&lt;/property&gt; &lt;!-- 级联操作: cascade save-update: 级联保存更新 delete:级联删除 all:save-update+delete 级联操作: 简化操作.目的就是为了少些两行代码. --&gt; &lt;set name=&quot;linkMens&quot; cascade=&quot;save-update&quot;&gt; &lt;key column=&quot;lkm_cust_id&quot;&gt;&lt;/key&gt; &lt;one-to-many class=&quot;LinkMan&quot;&gt;&lt;/one-to-many&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 3.2 示例代码12345678910111213141516171819202122232425262728293031323334353637/** * 保存客户 以及客户 下的联系人 * cascade:save-update */@Testpublic void test1()&#123; //1.获取session Session session = HibernateUtils.openSession(); //2.开启事务 Transaction t = session.beginTransaction(); //3.操作 Customer c = new Customer(); c.setCust_name(&quot;吊毛公司&quot;); LinkMan lm1 = new LinkMan(); lm1.setLkm_name(&quot;李吊毛&quot;); LinkMan lm2 = new LinkMan(); lm2.setLkm_name(&quot;高小飞&quot;); //表达一对多,客户下有多个联系人 c.getLinkMens().add(lm1); c.getLinkMens().add(lm2); //表达多对一,联系人属于哪个客户 lm1.setCustomer(c); lm2.setCustomer(c); session.save(c);// session.save(lm1);// session.save(lm2); //4.提交事务 t.commit(); //5.关闭资源 session.close();&#125; 3.3 结果客户表 image 联系人表 image 四、保存联系人以及联系人对应的客户首先我们应该想到，现在我们是保存联系人，然后保存联系人对应的客户。也是说，实际上我调用的只是保存联系人的方法。那么客户是级联上去。那么我们的级联就应该添加到 联系人的配置中。 注意：我们在测试的时候，删除之前创建的表。删除我们刚才在客户中配置级联 我们使用的级联是 save-update 也可以使用 all 4.1 LinkMan.hbm.xml123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package=&quot;com.qwm.hibernate03.domain&quot; &gt; &lt;class name=&quot;LinkMan&quot; table=&quot;cst_linkman&quot; &gt; &lt;id name=&quot;lkm_id&quot; &gt; &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;lkm_gender&quot; &gt;&lt;/property&gt; &lt;property name=&quot;lkm_name&quot; &gt;&lt;/property&gt; &lt;property name=&quot;lkm_phone&quot; &gt;&lt;/property&gt; &lt;property name=&quot;lkm_email&quot; &gt;&lt;/property&gt; &lt;property name=&quot;lkm_qq&quot; &gt;&lt;/property&gt; &lt;property name=&quot;lkm_mobile&quot; &gt;&lt;/property&gt; &lt;property name=&quot;lkm_memo&quot; &gt;&lt;/property&gt; &lt;property name=&quot;lkm_position&quot; &gt;&lt;/property&gt; &lt;!-- 多对一 --&gt; &lt;!-- name属性:引用属性名 column属性: 外键列名 class属性: 与我关联的对象完整类名 --&gt; &lt;many-to-one name=&quot;customer&quot; column=&quot;lkm_cust_id&quot; class=&quot;Customer&quot; cascade=&quot;save-update&quot;/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 4.2 示例代码1234567891011121314151617181920212223242526272829/** * 保存联系人以及联系人对应的客户 * cascade:save-update */@Testpublic void test2()&#123; //1.获取session Session session = HibernateUtils.openSession(); //2.开启事务 Transaction t = session.beginTransaction(); //3.操作 //3.1创建客户 //3.2创建我们的联系人 //3.3把联系人添加到客户的中 //3.4把客户添加到联系人中 //3.5保存联系人 Customer c = new Customer(); c.setCust_name(&quot;搞笑公司&quot;); LinkMan lm1 = new LinkMan(); lm1.setLkm_name(&quot;张笑话&quot;); c.getLinkMens().add(lm1); lm1.setCustomer(c); session.save(lm1); //4.提交事务 t.commit(); //5.关闭资源 session.close();&#125; 4.3 结果客户表 image 联系人表 image 这里写图片描述 五、删除客户时,级联删除客户下的联系人与上面的分析一样，我们的级联应该配置在 客户中。 我们使用的级联是 delete 也可以使用 all 5.1 Customer.hbm.xml1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package=&quot;com.qwm.hibernate03.domain&quot; &gt; &lt;class name=&quot;Customer&quot; table=&quot;cst_customer&quot; &gt; &lt;id name=&quot;cust_id&quot; &gt; &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;cust_name&quot; column=&quot;cust_name&quot; &gt;&lt;/property&gt; &lt;property name=&quot;cust_source&quot; column=&quot;cust_source&quot; &gt;&lt;/property&gt; &lt;property name=&quot;cust_industry&quot; column=&quot;cust_industry&quot; &gt;&lt;/property&gt; &lt;property name=&quot;cust_level&quot; column=&quot;cust_level&quot; &gt;&lt;/property&gt; &lt;property name=&quot;cust_linkman&quot; column=&quot;cust_linkman&quot; &gt;&lt;/property&gt; &lt;property name=&quot;cust_phone&quot; column=&quot;cust_phone&quot; &gt;&lt;/property&gt; &lt;property name=&quot;cust_mobile&quot; column=&quot;cust_mobile&quot; &gt;&lt;/property&gt; &lt;!-- 级联操作: cascade save-update: 级联保存更新 delete:级联删除 all:save-update+delete 级联操作: 简化操作.目的就是为了少些两行代码. --&gt; &lt;set name=&quot;linkMens&quot; cascade=&quot;delete&quot;&gt; &lt;key column=&quot;lkm_cust_id&quot;&gt;&lt;/key&gt; &lt;one-to-many class=&quot;LinkMan&quot;&gt;&lt;/one-to-many&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 5.2 示例代码123456789101112131415161718192021/** * 测试删除客户时,级联删除客户下的联系人 * cascade:delete */@Testpublic void test3()&#123; //1.获取session Session session = HibernateUtils.openSession(); //2.开启事务 Transaction t = session.beginTransaction(); //3.操作 //3.1获取到客户 //3.2获得客户 Customer c = session.get(Customer.class,1L); session.delete(c); //4.提交事务 t.commit(); //5.关闭资源 session.close();&#125; 5.3 结果客户表 image 联系人表 image","categories":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/categories/ssm/"},{"name":"hibernate","slug":"ssm/hibernate","permalink":"http://qiwenming.github.io/categories/ssm/hibernate/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/tags/ssm/"},{"name":"hibernate","slug":"hibernate","permalink":"http://qiwenming.github.io/tags/hibernate/"}]},{"title":"SSH与SSM学习之hibernate17——多对一一对多简单操作","slug":"hibernate/17","date":"2017-11-19T13:52:08.000Z","updated":"2018-01-18T13:51:53.577Z","comments":false,"path":"hibernate/17/2017/11/19/","link":"","permalink":"http://qiwenming.github.io/hibernate/17/2017/11/19/","excerpt":"","text":"SSH与SSM学习之hibernate17——多对一一对多简单操作一、说明现在有两个表，一个是客户表，一个是联系人表。它们之间存在一对多的关系。 见 SSH与SSM学习之hibernate16——表与表的三种关系 我们来简单实现一下。 二、实体类2.1 Customer 客户实体123456789101112131415161718192021222324package com.qwm.hibernate03.domain;import java.util.HashSet;import java.util.Set;/** * @author：qiwenming * @date：2017/9/18 0018 21:25 * @description： * */public class Customer &#123; private Long cust_id; private String cust_name; private String cust_source; private String cust_industry; private String cust_level; private String cust_linkman; private String cust_phone; private String cust_mobile; //使用set集合,表达一对多的关系 private Set&lt;LinkMan&gt; linkMens = new HashSet&lt;&gt;(); ....省略了get/set方法...&#125; 2.2 LinkMan 联系人实体12345678910111213141516171819202122package com.qwm.hibernate03.domain;/** * @author：qiwenming * @date：2017/9/18 0018 21:26 * @description： * 联系人 */public class LinkMan &#123; private Long lkm_id; private Character lkm_gender; private String lkm_name; private String lkm_phone; private String lkm_email; private String lkm_qq; private String lkm_mobile; private String lkm_memo; private String lkm_position; //表达多对一 private Customer customer; ....省略了get/set方法...&#125; 三、映射3.1 映射说明我们需要使用到一对多和多对一映射。这里我们用到的一对多映射是set,多对一映射是many-to-one set说明 例如：1234&lt;set name=&quot;linkMens&quot;&gt; &lt;key column=&quot;lkm_cust_id&quot;&gt;&lt;/key&gt; &lt;one-to-many class=&quot;LinkMan&quot;&gt;&lt;/one-to-many&gt;&lt;/set&gt; 说明： name属性:集合属性名 ：外键 column属性: 外键列名 one-to-many：一对多 class属性: 与我关联的对象完整类名 many-to-one说明 例如： 1&lt;many-to-one name=&quot;customer&quot; column=&quot;lkm_cust_id&quot; class=&quot;Customer&quot;/&gt; 说明： name属性:引用属性名 column属性: 外键列名 class属性: 与我关联的对象完整类名 ==注意：中的的column必须与 many-to-one 中的column一致== 3.2 Customer.hbm.xml1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package=&quot;com.qwm.hibernate03.domain&quot; &gt; &lt;class name=&quot;Customer&quot; table=&quot;cst_customer&quot; &gt; &lt;id name=&quot;cust_id&quot; &gt; &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;cust_name&quot; column=&quot;cust_name&quot; &gt;&lt;/property&gt; &lt;property name=&quot;cust_source&quot; column=&quot;cust_source&quot; &gt;&lt;/property&gt; &lt;property name=&quot;cust_industry&quot; column=&quot;cust_industry&quot; &gt;&lt;/property&gt; &lt;property name=&quot;cust_level&quot; column=&quot;cust_level&quot; &gt;&lt;/property&gt; &lt;property name=&quot;cust_linkman&quot; column=&quot;cust_linkman&quot; &gt;&lt;/property&gt; &lt;property name=&quot;cust_phone&quot; column=&quot;cust_phone&quot; &gt;&lt;/property&gt; &lt;property name=&quot;cust_mobile&quot; column=&quot;cust_mobile&quot; &gt;&lt;/property&gt; &lt;!-- 集合,一对多关系,在配置文件中配置 --&gt; &lt;!-- name属性:集合属性名 column属性: 外键列名 class属性: 与我关联的对象完整类名 --&gt; &lt;set name=&quot;linkMens&quot; inverse=&quot;true&quot; cascade=&quot;delete&quot;&gt; &lt;key column=&quot;lkm_cust_id&quot;&gt;&lt;/key&gt; &lt;one-to-many class=&quot;LinkMan&quot;&gt;&lt;/one-to-many&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 3.3 LinkMan.hbm.xml1234567891011121314151617181920212223242526&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package=&quot;com.qwm.hibernate03.domain&quot; &gt; &lt;class name=&quot;LinkMan&quot; table=&quot;cst_linkman&quot; &gt; &lt;id name=&quot;lkm_id&quot; &gt; &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;lkm_gender&quot; &gt;&lt;/property&gt; &lt;property name=&quot;lkm_name&quot; &gt;&lt;/property&gt; &lt;property name=&quot;lkm_phone&quot; &gt;&lt;/property&gt; &lt;property name=&quot;lkm_email&quot; &gt;&lt;/property&gt; &lt;property name=&quot;lkm_qq&quot; &gt;&lt;/property&gt; &lt;property name=&quot;lkm_mobile&quot; &gt;&lt;/property&gt; &lt;property name=&quot;lkm_memo&quot; &gt;&lt;/property&gt; &lt;property name=&quot;lkm_position&quot; &gt;&lt;/property&gt; &lt;!-- 多对一 --&gt; &lt;!-- name属性:引用属性名 column属性: 外键列名 class属性: 与我关联的对象完整类名 --&gt; &lt;many-to-one name=&quot;customer&quot; column=&quot;lkm_cust_id&quot; class=&quot;Customer&quot;/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 3.4 hibernate.cfg.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!--数据库驱动--&gt; &lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;!--数据库url--&gt; &lt;property name=&quot;hibernate.connection.url&quot;&gt;jdbc:mysql://localhost:3306/htest&lt;/property&gt; &lt;!--数据库连接用户名--&gt; &lt;property name=&quot;hibernate.connection.username&quot;&gt;root&lt;/property&gt; &lt;!--数据库连接密码--&gt; &lt;property name=&quot;hibernate.connection.password&quot;&gt;xm123456&lt;/property&gt; &lt;!--数据库方言--&gt; &lt;!-- 数据库方言 不同的数据库中,sql语法略有区别. 指定方言可以让hibernate框架在生成sql语句时.针对数据库的方言生成. sql99标准: DDL 定义语言 库表的增删改查 DCL 控制语言 事务 权限 DML 操纵语言 增删改查 --&gt; &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL5Dialect&lt;/property&gt; &lt;!-- #hibernate.show_sql true #hibernate.format_sql true--&gt; &lt;!-- 将hibernate生成的sql语句打印到控制台 --&gt; &lt;property name=&quot;hibernate.show_sql&quot;&gt;true&lt;/property&gt; &lt;!-- 将hibernate生成的sql语句格式化(语法缩进) --&gt; &lt;property name=&quot;hibernate.format_sql&quot;&gt;true&lt;/property&gt; &lt;!-- ## auto schema export 自动导出表结构. 自动建表 #hibernate.hbm2ddl.auto create 自动建表.每次框架运行都会创建新的表.以前表将会被覆盖,表数据会丢失.(开发环境中测试使用) #hibernate.hbm2ddl.auto create-drop 自动建表.每次框架运行结束都会将所有表删除.(开发环境中测试使用) #hibernate.hbm2ddl.auto update(推荐使用) 自动生成表.如果已经存在不会再生成.如果表有变动.自动更新表(不会删除任何数据). #hibernate.hbm2ddl.auto validate 校验.不自动生成表.每次启动会校验数据库中表是否正确.校验失败. --&gt; &lt;!--自动创建表--&gt; &lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/property&gt; &lt;!--指定session与当前线程绑定--&gt; &lt;property name=&quot;hibernate.current_session_context_class&quot;&gt;thread&lt;/property&gt; &lt;!--导入 User 配置--&gt; &lt;!-- 引入orm元数据 路径书写: 填写src下的路径 --&gt; &lt;mapping resource=&quot;com/qwm/hibernate03/domain/Customer.hbm.xml&quot;&gt;&lt;/mapping&gt; &lt;mapping resource=&quot;com/qwm/hibernate03/domain/LinkMan.hbm.xml&quot;&gt;&lt;/mapping&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 四、测试demo4.1 保存客户 以及客户 下的联系人4.1.1 实例代码123456789101112131415161718192021222324252627282930313233343536/** * 保存客户 以及客户 下的联系人 */@Testpublic void test1()&#123; //1.获取session Session session = HibernateUtils.openSession(); //2.开启事务 Transaction t = session.beginTransaction(); //3.操作 Customer c = new Customer(); c.setCust_name(&quot;吊毛公司&quot;); LinkMan lm1 = new LinkMan(); lm1.setLkm_name(&quot;李吊毛&quot;); LinkMan lm2 = new LinkMan(); lm2.setLkm_name(&quot;高小飞&quot;); //表达一对多,客户下有多个联系人 c.getLinkMens().add(lm1); c.getLinkMens().add(lm2); //表达多对一,联系人属于哪个客户 lm1.setCustomer(c); lm2.setCustomer(c); session.save(c); session.save(lm1); session.save(lm2); //4.提交事务 t.commit(); //5.关闭资源 session.close();&#125; 4.1.2 结果客户表 联系人表 4.2 为客户添加联系人4.2.1 实例代码123456789101112131415161718192021222324252627/** * 为客户添加联系人 */@Testpublic void test2()&#123; //1.获取session Session session = HibernateUtils.openSession(); //2.开启事务 Transaction t = session.beginTransaction(); //3.操作 //3.1获取到客户 //3.2创建我们的联系人 //3.3把联系人添加到客户的中 //3.4把客户添加到联系人中 //3.5保存联系人 Customer c = session.get(Customer.class,1L); LinkMan lm1 = new LinkMan(); lm1.setLkm_name(&quot;小明&quot;); c.getLinkMens().add(lm1); lm1.setCustomer(c); session.save(lm1); //4.提交事务 t.commit(); //5.关闭资源 session.close();&#125; 4.2.2 结果联系人表 4.3 为客户删除联系人4.3.1 实例代码1234567891011121314151617181920212223/** * 为客户删除联系人 */@Testpublic void test3()&#123; //1.获取session Session session = HibernateUtils.openSession(); //2.开启事务 Transaction t = session.beginTransaction(); //3.操作 //3.1获取到客户 //3.2获得要移除的联系人 //3.3将联系人从客户集合中移除 Customer c = session.get(Customer.class,1L); LinkMan lm = session.get(LinkMan.class,3L); c.getLinkMens().remove(lm); lm.setCustomer(null); //4.提交事务 t.commit(); //5.关闭资源 session.close();&#125; 4.3.2 结果联系人表","categories":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/categories/ssm/"},{"name":"hibernate","slug":"ssm/hibernate","permalink":"http://qiwenming.github.io/categories/ssm/hibernate/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/tags/ssm/"},{"name":"hibernate","slug":"hibernate","permalink":"http://qiwenming.github.io/tags/hibernate/"}]},{"title":"SSH与SSM学习之hibernate16——表与表的三种关系","slug":"hibernate/16","date":"2017-11-19T13:52:07.000Z","updated":"2018-01-18T13:51:53.575Z","comments":false,"path":"hibernate/16/2017/11/19/","link":"","permalink":"http://qiwenming.github.io/hibernate/16/2017/11/19/","excerpt":"","text":"SSH与SSM学习之hibernate16——表与表的三种关系一、表与表的三种关系表与表之间有三种关系 一对多|多对一 多对多 一对一 二、表与表的三种关系数据库表中的表现2.1 一对多|多对一建表原则：在多的一方创建外键指向一的一方的主键 这里写图片描述 2.2 多对多建表原则：创建一个中间表，中间表中至少两个字段作为外键分别指向多对多双方的主键。 这里写图片描述 2.3 一对一其实这种关系可以弄成一张表。 一对一建表原则有两种： 第一种：唯一外键对应，假设一对一中任意一方为多，在多的一方创建外键指向一的一方的主键，然后将外键设置为唯一。 这里写图片描述 第一个种：主键对应。一方的主键作为另一方的主键。 这里写图片描述 三、Java对象中的表达3.1 一对一123456789public class A&#123; public B b;&#125; public class B&#123; publc A a;&#125; 3.2 一对多123456789public class A&#123; public Set&lt;B&gt; bs;//B的集合&#125; public class B&#123; publc A a;&#125; 3.3 多对多123456789public class A&#123; public Set&lt;B&gt; bs;//B的集合&#125; public class B&#123; publc Set&lt;A&gt; as;//A的集合&#125;","categories":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/categories/ssm/"},{"name":"hibernate","slug":"ssm/hibernate","permalink":"http://qiwenming.github.io/categories/ssm/hibernate/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/tags/ssm/"},{"name":"hibernate","slug":"hibernate","permalink":"http://qiwenming.github.io/tags/hibernate/"}]},{"title":"SSH与SSM学习之hibernate15——SQL原生查询","slug":"hibernate/15","date":"2017-11-19T13:52:06.000Z","updated":"2018-01-18T13:51:53.574Z","comments":false,"path":"hibernate/15/2017/11/19/","link":"","permalink":"http://qiwenming.github.io/hibernate/15/2017/11/19/","excerpt":"","text":"SSH与SSM学习之hibernate15——SQL原生查询一、原生查询说明原生查询我们只要使用到的方法是： 123456789//执行原生的sqlsession.createSQLQuery(sql)//指定将结果集封装到哪个对象中query.addEntity(User.class);//添加参数 query.setParameter(0,1); 二、基本查询2.1 示例代码1234567891011121314151617181920212223/** * Sql基本查询 */@Testpublic void sqlBaseDemo()&#123; //1.创建session Session session = HibernateUtils.openSession(); //------------------基本查询--------------- //2.写sql语句 String sql = &quot;select * from tb_user2&quot;; //3.创建sql查询对象 SQLQuery query = session.createSQLQuery(sql); //4.指定将结果集封装到哪个对象中 query.addEntity(User.class); //5.查询结果 List&lt;User&gt; users = query.list(); System.out.println(users); //----------------------------------------- //6.关闭资源 session.close();&#125; 2.2 查询结果123456Hibernate: select * from tb_user2[User&#123;id=1, name=&apos;小明&apos;, age=20&#125;, User&#123;id=2, name=&apos;xiaoming&apos;, age=19&#125;, User&#123;id=3, name=&apos;mingming&apos;, age=22&#125;, User&#123;id=4, name=&apos;mingge&apos;, age=20&#125;, User&#123;id=5, name=&apos;xx&apos;, age=99&#125;, User&#123;id=6, name=&apos;wiming&apos;, age=20&#125;] 三、条件查询3.1 示例代码12345678910111213141516171819202122232425 /** * sql 条件查询 */@Testpublic void sqlConditionDemo()&#123; //1.创建session Session session = HibernateUtils.openSession(); //------------------条件查询--------------- //2.写sql语句 String sql = &quot;select * from tb_user2 where id=?&quot;; //3.创建sql查询对象 SQLQuery query = session.createSQLQuery(sql); //4.指定将结果集封装到哪个对象中 query.addEntity(User.class); //5.添加参数 query.setParameter(0,1); //6.查询结果 List&lt;User&gt; users = query.list(); System.out.println(users); //----------------------------------------- //7.关闭资源 session.close();&#125; 3.2 查询结果12345678Hibernate: select * from tb_user2 where id=?[User&#123;id=1, name=&apos;小明&apos;, age=20&#125;] 四、分页查询4.1 示例代码1234567891011121314151617181920212223242526/** * Sql分页 */@Testpublic void sqlPageDemo()&#123; //1.创建session Session session = HibernateUtils.openSession(); //------------------分页查询--------------- //2.写sql语句 String sql = &quot;select * from tb_user2 limit ?,? &quot;; //3.创建sql查询对象 SQLQuery query = session.createSQLQuery(sql); //4.指定将结果集封装到哪个对象中 query.addEntity(User.class); //5.添加参数 query.setParameter(0,0); query.setParameter(1,3); //6.查询结果 List&lt;User&gt; users = query.list(); System.out.println(users); //----------------------------------------- //7.关闭资源 session.close();&#125; 4.2 查询结果1234567Hibernate: select * from tb_user2 limit ?, ? [User&#123;id=1, name=&apos;小明&apos;, age=20&#125;, User&#123;id=2, name=&apos;xiaoming&apos;, age=19&#125;, User&#123;id=3, name=&apos;mingming&apos;, age=22&#125;]","categories":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/categories/ssm/"},{"name":"hibernate","slug":"ssm/hibernate","permalink":"http://qiwenming.github.io/categories/ssm/hibernate/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/tags/ssm/"},{"name":"hibernate","slug":"hibernate","permalink":"http://qiwenming.github.io/tags/hibernate/"}]},{"title":"SSH与SSM学习之hibernate14——Criteria查询","slug":"hibernate/14","date":"2017-11-19T13:52:05.000Z","updated":"2018-01-18T13:51:53.572Z","comments":false,"path":"hibernate/14/2017/11/19/","link":"","permalink":"http://qiwenming.github.io/hibernate/14/2017/11/19/","excerpt":"","text":"SSH与SSM学习之hibernate14——Criteria查询一、Criteria比较适合单表查询。Hibernate自创的无语句面向对象查询。 Criteria 中拥有查询的方法，如 list() ,uniqueResult()等。二、基本查询2.1 示例代码1234567891011121314151617181920/** * Criteria基本查询 */@Testpublic void criteriaBaseDemo()&#123; //1.创建session Session session = HibernateUtils.openSession(); //------------------基本查询--------------- //2.创建Criteria查询对象 Criteria criteria = session.createCriteria(User.class); //3.获取集合 List&lt;User&gt; users = criteria.list(); //4.打印 System.out.println(users); //----------------------------------------- //5.关闭资源 session.close();&#125; 2.1 查询结果12345678Hibernate: select this_.id as id1_0_0_, this_.name as name2_0_0_, this_.age as age3_0_0_ from tb_user2 this_[User&#123;id=1, name=&apos;小明&apos;, age=20&#125;, User&#123;id=2, name=&apos;xiaoming&apos;, age=19&#125;, User&#123;id=3, name=&apos;mingming&apos;, age=22&#125;, User&#123;id=4, name=&apos;mingge&apos;, age=20&#125;, User&#123;id=5, name=&apos;xx&apos;, age=99&#125;, User&#123;id=6, name=&apos;wiming&apos;, age=20&#125;] 三、条件查询3.1 说明使用添加查询，我们需要个Criteria添加条件，我们主要使用到 Restrictions这个类的方法 sql中的表达式 Restrictions中的方法 &gt; gt &gt;= ge &lt; lt &lt;= le == eq != ne in in between and between like like is not null isNotNull is null isNull or or and and 3.2 示例代码1234567891011121314151617181920212223242526272829303132333435/** * Criteria 条件查询HQL语句中,不可能出现任何数据库相关的信息的 &gt; gt &gt;= ge &lt; lt &lt;= le == eq != ne in in between and between like like is not null isNotNull is null isNull or or and and */@Testpublic void criteriaConditionDemo()&#123; //1.创建session Session session = HibernateUtils.openSession(); //------------------条件查询--------------- //2.获取Criteria对象 Criteria criteria = session.createCriteria(User.class); //3.添加查询参数---&gt; id 为1的User对象 criteria.add(Restrictions.eq(&quot;id&quot;,1)); User user = (User) criteria.uniqueResult(); //4.打印 System.out.println(user); //----------------------------------------- //5.关闭资源 session.close();&#125; 3.3 查询结果12345678910Hibernate: select this_.id as id1_0_0_, this_.name as name2_0_0_, this_.age as age3_0_0_ from tb_user2 this_ where this_.id=?User&#123;id=1, name=&apos;小明&apos;, age=20&#125; 四、分页查询4.1 示例代码123456789101112131415161718192021222324/** * Criteria分页 */@Testpublic void criteriaPageDemo()&#123; //1.创建session Session session = HibernateUtils.openSession(); //------------------条件查询--------------- //2.创建Criteria查询对象 Criteria criteria = session.createCriteria(User.class); //3.设置分页信息 // 从0开始查询 criteria.setFirstResult(0); // 查询3条数据 criteria.setMaxResults(3); //4.执行查询 List&lt;User&gt; users = criteria.list(); //5.打印 System.out.println(users); //----------------------------------------- //6.关闭资源 session.close();&#125; 4.2 查询结果12345678Hibernate: select this_.id as id1_0_0_, this_.name as name2_0_0_, this_.age as age3_0_0_ from tb_user2 this_ limit ?[User&#123;id=1, name=&apos;小明&apos;, age=20&#125;, User&#123;id=2, name=&apos;xiaoming&apos;, age=19&#125;, User&#123;id=3, name=&apos;mingming&apos;, age=22&#125;] 五、查询总记录数5.1 聚合函数Criteria 中我们可以使用聚合函数。如下12//3. 设置查询的聚合函数 =&gt; 总行数criteria.setProjection(Projections.rowCount()); Projections中定义了很多聚合函数，例如 sum、avg、count、max、min等 5.2 示例代码123456789101112131415161718192021/** * Criteria查询总记录数 */@Testpublic void criteriaTotalDemo()&#123; //1.创建session Session session = HibernateUtils.openSession(); //------------------条件查询--------------- //2.创建Criteria查询对象 Criteria criteria = session.createCriteria(User.class); //3. 设置查询的聚合函数 =&gt; 总行数 criteria.setProjection(Projections.rowCount()); //4. 查询 Long count = (Long)criteria.uniqueResult(); //5. 打印 System.out.println(&quot;总条数：&quot;+count); //----------------------------------------- //6.关闭资源 session.close();&#125; 5.3 查询结果123456Hibernate: select count(*) as y0_ from tb_user2 this_总条数：6","categories":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/categories/ssm/"},{"name":"hibernate","slug":"ssm/hibernate","permalink":"http://qiwenming.github.io/categories/ssm/hibernate/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/tags/ssm/"},{"name":"hibernate","slug":"hibernate","permalink":"http://qiwenming.github.io/tags/hibernate/"}]},{"title":"SSH与SSM学习之hibernate13——HQL查询","slug":"hibernate/13","date":"2017-11-19T13:52:04.000Z","updated":"2018-01-18T13:51:53.570Z","comments":false,"path":"hibernate/13/2017/11/19/","link":"","permalink":"http://qiwenming.github.io/hibernate/13/2017/11/19/","excerpt":"","text":"SSH与SSM学习之hibernate13——HQL查询一、hibernate查询说明hibernate查询，主要使用以下三种 HQL查询-hibernate Query Language(主要用于多表查询,但不复杂时使用) Criteria查询(主要用于单表条件查询) 原生SQL查询(复杂的业务查询) 二、HQL查询HQL查询-hibernate Query Language(主要用于多表查询,但不复杂时使用) Hibernate独家查询语言,属于面向对象的查询语言 三、基本查询这个基本查询是查询全部的 3.1 示例代码123456789101112131415161718192021222324252627/** * HQL基本查询 */@Testpublic void qhlBaseDemo()&#123; //1.创建session Session session = HibernateUtils.openSession(); //------------------基本查询--------------- //查询全部，如果User类有不能唯一确定，那么需要完整类名 String sql = &quot;from User&quot;; Query query = session.createQuery(sql); //多个结果可以使用list() List&lt;User&gt; users = query.list(); //如果是一个唯一的结果，那么可以使使用 //query.uniqueResult(); //打印集合 System.out.println(users); //----------------------------------------- //5.关闭资源 session.close();&#125; 3.2 查询结果12345678Hibernate: select user0_.id as id1_0_, user0_.name as name2_0_, user0_.age as age3_0_ from tb_user2 user0_[User&#123;id=1, name=&apos;小明&apos;, age=20&#125;, User&#123;id=2, name=&apos;xiaoming&apos;, age=19&#125;, User&#123;id=3, name=&apos;mingming&apos;, age=22&#125;, User&#123;id=4, name=&apos;mingge&apos;, age=20&#125;, User&#123;id=5, name=&apos;xx&apos;, age=99&#125;, User&#123;id=6, name=&apos;wiming&apos;, age=20&#125;] 四、条件查询，条件直接写死4.1 示例代码123456789101112131415161718192021222324/** * HQL条件查询，条件直接写死 */@Testpublic void qhlConditionDemo1()&#123; //1.创建session Session session = HibernateUtils.openSession(); //------------------条件查询--------------- //查询全部，如果User类有不能唯一确定，那么需要完整类名 //这里id是User类的id String sql = &quot;from User where id = 1&quot;; Query&lt;User&gt; query = session.createQuery(sql); //如果是一个唯一的结果，那么可以使使用 User user = query.uniqueResult(); //打印 System.out.println(user); //----------------------------------------- //5.关闭资源 session.close();&#125; 4.2 查询结果12345678910Hibernate: select user0_.id as id1_0_, user0_.name as name2_0_, user0_.age as age3_0_ from tb_user2 user0_ where user0_.id=1User&#123;id=1, name=&apos;小明&apos;, age=20&#125; 五、条件查询，使用 ？占位符5.1 示例代码12345678910111213141516171819202122232425/** * HQL条件查询，使用 ？占位符 */@Testpublic void qhlConditionDemo2()&#123; //1.创建session Session session = HibernateUtils.openSession(); //------------------条件查询--------------- //查询全部，如果User类有不能唯一确定，那么需要完整类名 //这里id是User类的id String sql = &quot;from User where id = ?&quot;; Query&lt;User&gt; query = session.createQuery(sql); //添加参数,下标从0开始 query.setParameter(0,1); //如果是一个唯一的结果，那么可以使使用 User user = query.uniqueResult(); //打印 System.out.println(user); //----------------------------------------- //5.关闭资源 session.close();&#125; 5.2 查询结果12345678910Hibernate: select user0_.id as id1_0_, user0_.name as name2_0_, user0_.age as age3_0_ from tb_user2 user0_ where user0_.id=?User&#123;id=1, name=&apos;小明&apos;, age=20&#125; 六、条件查询，使用 命名占位符6.1 示例代码12345678910111213141516171819202122232425/** * HQL条件查询，使用 命名占位符 */@Testpublic void qhlConditionDemo3()&#123; //1.创建session Session session = HibernateUtils.openSession(); //------------------条件查询--------------- //查询全部，如果User类有不能唯一确定，那么需要完整类名 //这里id是User类的id String sql = &quot;from User where id = :uid&quot;; Query&lt;User&gt; query = session.createQuery(sql); //添加参数 query.setParameter(&quot;uid&quot;,1); //如果是一个唯一的结果，那么可以使使用 User user = query.uniqueResult(); //打印 System.out.println(user); //----------------------------------------- //5.关闭资源 session.close();&#125; 6.2 查询结果12345678910Hibernate: select user0_.id as id1_0_, user0_.name as name2_0_, user0_.age as age3_0_ from tb_user2 user0_ where user0_.id=?User&#123;id=1, name=&apos;小明&apos;, age=20&#125; 七、分页查询7.1 示例代码123456789101112131415161718192021222324252627/** * HQL分页 */@Testpublic void qhlPageDemo()&#123; //1.创建session Session session = HibernateUtils.openSession(); //------------------条件查询--------------- //查询全部，如果User类有不能唯一确定，那么需要完整类名 //这里id是User类的id String sql = &quot;from User&quot;; Query&lt;User&gt; query = session.createQuery(sql); //从第0条开始 query.setFirstResult(0); //查询3条数据 query.setMaxResults(3); List&lt;User&gt; users = query.list(); //打印 System.out.println(users); //----------------------------------------- //5.关闭资源 session.close();&#125; 7.2 查询结果12345678Hibernate: select user0_.id as id1_0_, user0_.name as name2_0_, user0_.age as age3_0_ from tb_user2 user0_ limit ?[User&#123;id=1, name=&apos;小明&apos;, age=20&#125;, User&#123;id=2, name=&apos;xiaoming&apos;, age=19&#125;, User&#123;id=3, name=&apos;mingming&apos;, age=22&#125;]","categories":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/categories/ssm/"},{"name":"hibernate","slug":"ssm/hibernate","permalink":"http://qiwenming.github.io/categories/ssm/hibernate/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/tags/ssm/"},{"name":"hibernate","slug":"hibernate","permalink":"http://qiwenming.github.io/tags/hibernate/"}]},{"title":"SSH与SSM学习之hibernate12——hibernate中的事务","slug":"hibernate/12","date":"2017-11-19T13:52:03.000Z","updated":"2018-01-18T13:51:53.569Z","comments":false,"path":"hibernate/12/2017/11/19/","link":"","permalink":"http://qiwenming.github.io/hibernate/12/2017/11/19/","excerpt":"","text":"SSH与SSM学习之hibernate12——hibernate中的事务一、事务1.1 事务特性原子性 一致性 隔离性 持久性 1.2 事务并发问题脏读 不可重复度 幻|虚读 1.3 事务隔离级别读未提交（脏读、不可重复度、幻|虚读） 读已提交（不可重复度、幻|虚读） 可重复读(mysql默认级别)（幻|虚读） 串行化 - 没有问题 二、如何在hibernate中指定数据库的隔离级别配置事务的隔离级别，需要在hibernate的主配置文件hibernate.cfg.xml中添加如下的配置 12345678&lt;!-- 指定hibernate操作数据库时的隔离级别 #hibernate.connection.isolation 1|2|4|8 0001 1 读未提交 0010 2 读已提交 0100 4 可重复读 1000 8 串行化--&gt;&lt;property name=&quot;hibernate.connection.isolation&quot;&gt;4&lt;/property&gt; 三、在项目中如何管理事务3.1 管理事务说明 业务开始之前打开事务,业务执行之后提交事务. 执行过程中出现异常.回滚事务. 在dao层操作数据库需要用到session对象.在service控制事务也是使用session对象完成. 我们要确保dao层和service层使用的使用同一个session对象 在hibernate中,确保使用同一个session的问题,hibernate已经帮我们解决了. 我们开发人员只需要调用sf.getCurrentSession()方法即可获得与当前线程绑定的session对象 3.2 getCurrentSession() 使用说明 调用getCurrentSession方法必须配合主配置中的一段配置 12&lt;!--指定session与当前线程绑定--&gt;&lt;property name=&quot;hibernate.current_session_context_class&quot;&gt;thread&lt;/property&gt; 通过getCurrentSession方法获得的session对象.当事务提交时,session会自动关闭.不要手动调用close关闭. 四、service和dao实例4.1 CustomerDaoImpl12345678910111213141516171819202122package com.qwm.hcrm.dao.impl;import com.qwm.hcrm.dao.CustomerDao;import com.qwm.hcrm.dmain.Customer;import com.qwm.hcrm.utils.HibernateUtils;import org.hibernate.Session;import org.hibernate.Transaction;/** * @author：qiwenming * @date：2017/9/17 0017 0:58 * @description： */public class CustomerDaoImpl implements CustomerDao&#123; @Override public void save(Customer customer) &#123; //1.获取session Session session = HibernateUtils.getCurrentSession(); //2.保存对象 session.save(customer); &#125;&#125; 4.2 CustomerServiceImpl1234567891011121314151617181920212223242526272829303132package com.qwm.hcrm.service.impl;import com.qwm.hcrm.dao.CustomerDao;import com.qwm.hcrm.dao.impl.CustomerDaoImpl;import com.qwm.hcrm.dmain.Customer;import com.qwm.hcrm.service.CustomerService;import com.qwm.hcrm.utils.HibernateUtils;import org.hibernate.Session;import org.hibernate.Transaction;/** * @author：qiwenming * @date：2017/9/17 0017 1:02 * @description： */public class CustomerServiceImpl implements CustomerService&#123; private CustomerDao customerDao = new CustomerDaoImpl(); @Override public void save(Customer customer) &#123; Session session = HibernateUtils.getCurrentSession(); //打开事务 Transaction t = session.beginTransaction(); try &#123; customerDao.save(customer); &#125;catch (Exception e)&#123; e.printStackTrace(); t.rollback(); &#125; //提交事务 t.commit(); &#125;&#125;","categories":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/categories/ssm/"},{"name":"hibernate","slug":"ssm/hibernate","permalink":"http://qiwenming.github.io/categories/ssm/hibernate/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/tags/ssm/"},{"name":"hibernate","slug":"hibernate","permalink":"http://qiwenming.github.io/tags/hibernate/"}]},{"title":"SSH与SSM学习之hibernate11——二级缓存","slug":"hibernate/11","date":"2017-11-19T13:52:02.000Z","updated":"2018-01-18T13:51:53.567Z","comments":false,"path":"hibernate/11/2017/11/19/","link":"","permalink":"http://qiwenming.github.io/hibernate/11/2017/11/19/","excerpt":"","text":"SSH与SSM学习之hibernate11——二级缓存一、一级缓存解决不了多个session的问题比如现在我们查询的数据，基本是不变的，在一级缓存（session缓存）下，我们如果是同一个session,那么有数据被缓存，但是如果我们是多个session的话，那么我们还是会多次去访问数据。然而由于数据是不变的，我们完全没必要呀。我们想要实现的就是多个session也能够直接使用，而不去查询，这样我们的二级缓存就来了。 二、二级缓存二级缓存是SessionFactory级别的缓存，是属于进程范围的缓存。 二级缓存又称为“全局缓存”、“应用缓存” 二级缓存中的数据可适用范围是当前应用程序的所有回话 二级缓存是可插拔式缓存，默认是 EHCache,还支持其他二级缓存组件 例如：Hashtable、OSCache、SwarmCache、JBoss TreeCache等 三、二级缓存配置步骤3.1 添加二级缓存对应的jar包在我们下载的 hibernate 的文件中，有个路径是 lib\\optional\\ehcache，导入里面的jar包. 例如我们的是 123456ehcache-2.10.3.jarhibernate-ehcache-5.2.11.Final.jarslf4j-api-1.7.7.jar 不能缺少任何一个包哦。如果缺少了 hibernate-ehcache-5.2.11.Final.jar，会出现下面的错误 1Caused by: org.hibernate.boot.registry.selector.spi.StrategySelectionException: Unable to resolve name [org.hibernate.cache.ehcache.EhCacheRegionFactory] as strategy [org.hibernate.cache.spi.RegionFactory .......... 3.2 在hibernate的主配置文件中添加配置我们需要在hibernate.cfg.xml中添加相应的配置，我们需要添加如下配置。 Hibernate 4.0及以后12345&lt;!--配置二级缓存的外部实现类--&gt;&lt;property name=&quot;hibernate.cache.provider_class&quot;&gt;net.sf.ehcache.hibernate.EhCacheProvider&lt;/property&gt;&lt;!--开启二级缓存--&gt;&lt;property name=&quot;hibernate.cache.use_second_level_cache&quot;&gt;true&lt;/property&gt;&lt;property name=&quot;hibernate.cache.region.factory_class&quot;&gt;org.hibernate.cache.ehcache.EhCacheRegionFactory&lt;/property&gt; Hibernate 3.3123&lt;property name=&quot;hibernate.cache.use_second_level_cache&quot;&gt;true&lt;/property&gt; &lt;property name=&quot;cache.provider_class&quot;&gt;org.hibernate.cache.EhCacheProvider&lt;/property&gt; 3.3 添加二级缓存的属性配置文件导入的 ehcache.xml 到 src下 3.4 在需要被缓存的表所对应的映射文件中添加标签下载我们需要在我们需要使用二级缓存的配置文件中加入 标签。如下 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package=&quot;com.qwm.hibernate02&quot;&gt; &lt;class name=&quot;User&quot; table=&quot;tb_user2&quot;&gt; &lt;!--二级缓存配置--&gt; &lt;cache usage=&quot;read-only&quot; include=&quot;all&quot; region=&quot;User&quot;&gt;&lt;/cache&gt; &lt;id name=&quot;id&quot;&gt; &lt;!--id自增--&gt; &lt;generator class=&quot;increment&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;name&quot;/&gt; &lt;property name=&quot;age&quot;/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 四、标签说明4.1 usageusage：指定缓存策略，可选的策略是包括：transactional,read-write、nonstrict-read-write或read-only 这个具体含义可以查看 详解Hibernate中的二级缓存 4.2 includeinclude（可选,默认为 all） non-lazy 当属性级延迟抓取打开时，标记为 lazy=”true” 的实体的属性可能无法被 4.3 regionregion （可选，默认为类或者集合的名字（class or collection role name）） 指定第二级缓存的区域名（name of the second level cache region） 在 ehcache.xml 配置 五、代码测试5.1 测试代码12345678910111213141516171819202122/** * 二级缓存，我们使用多个session来查询数据 */@Testpublic void cacheTest1()&#123; //1.创建session Session session = HibernateUtils.openSession(); //2.获取到数据 User user1 = session.get(User.class,1); System.out.println(user1); //3.创建新的session session = HibernateUtils.openSession(); //4.获取数据 User user2 = session.get(User.class,1); System.out.println(user2); //5.关闭资源 session.close();&#125; 5.2 没有二级缓存的结果1234567891011121314151617181920Hibernate: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_ from tb_user2 user0_ where user0_.id=?User&#123;id=1, name=&apos;小明&apos;, age=20&#125;Hibernate: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_ from tb_user2 user0_ where user0_.id=?User&#123;id=1, name=&apos;小明&apos;, age=20&#125; 5.3 有二级缓存的结果1234567891011Hibernate: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_ from tb_user2 user0_ where user0_.id=?User&#123;id=1, name=&apos;小明&apos;, age=20&#125;User&#123;id=1, name=&apos;小明&apos;, age=20&#125;","categories":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/categories/ssm/"},{"name":"hibernate","slug":"ssm/hibernate","permalink":"http://qiwenming.github.io/categories/ssm/hibernate/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/tags/ssm/"},{"name":"hibernate","slug":"hibernate","permalink":"http://qiwenming.github.io/tags/hibernate/"}]},{"title":"SSH与SSM学习之hibernate10——Hibernate的一级缓存","slug":"hibernate/10","date":"2017-11-19T13:52:01.000Z","updated":"2018-01-18T13:51:53.566Z","comments":false,"path":"hibernate/10/2017/11/19/","link":"","permalink":"http://qiwenming.github.io/hibernate/10/2017/11/19/","excerpt":"","text":"SSH与SSM学习之hibernate10——Hibernate的一级缓存一、Hibernate的一级缓存1 缓存是计算机领域非常通用的概念。它介于应用程序和永久性数据存储源(如硬盘上的文件或者数据库)之间， 其作用是降低应用程序直接读写永久性数据存储源的频率，从而提高应用的运行性能。 缓存中的数据是数据存储源中数据的拷贝。缓存的物理介质通常是内存。 2 hibernate的缓存分为一级缓存和二级缓存， Hibernate的这两级缓存都位于持久化层， 存储的都是数据库数据的备份。其屮第一级缓存为hibernate的内存缓存，不能被卸载。 1.1 什么是Hibernate的一级缓存1 Hibernate的一级缓存就是指Session缓存， Session缓存是一块内存空间， 用来存放相互管理的java对象，在使用Hibernate查询对象的时候， 首先会使用对象属性的OID值在Hibernate的一级缓存中进行查找， 如果找到匹配OID值的对象，就直接将该对象从一级缓存中取出使用，不会再查询数据库 ； 如果没有找到相同OID值的对象，则会去数据库中查找相应数据。 当从数据库中查询到所需数据时，该数据信息也会放置到一级缓存中。 hibernate的一级缓存的作用就足减少对数据库的访问次数 1.2 Hibernate的一级缓存的特点 在Session接口的实现中包含一系列的 Java集合，这些Java集合构成了 Session缓存。 只要Session实例没有结束生命周期，存放在它缓存中的对象也不会结束生命周期。 固一级缓存也被称为是Session基本的缓存。 Hibernate的一级缓存有如下特点： 当应用程序调用Session接门的save()、 update()、 saveOrUpdate时，如果Session缓存中没有相应的对象， Hibernate就会自动的把从数据库中查询到的相应对象信息加入到一级缓存中去。 当调用Session接口的load()、 get()方法，以及Query接口的list()、 iterator()方法时，会判断缓存中是否存在该对象，有则返回，不会查询数据库，如果缓存中没有要杳询对象，再去数据库中杳询对应对象，并添加到一级缓存中。 当调用Session的close()方法时， Session缓存会被清空 二、证明一级缓存存在下面我们来使创建我们的代码，证明一级缓存的存在。 2.1 代码实例1234567891011121314151617181920212223242526/** * 一级缓存测试一 证明一级缓存存在 */@Testpublic void cacheTest1()&#123; //1.创建session Session session = HibernateUtils.openSession(); //2.开启事务 Transaction t = session.beginTransaction(); //3.查询对象 User user1 = session.get(User.class,1); User user2 = session.get(User.class,1); User user3 = session.get(User.class,1); User user4 = session.get(User.class,1); User user5 = session.get(User.class,1); //打印 System.out.println( &quot;user1 == user2 : &quot; + (user1 == user2)); System.out.println( &quot;user1 == user3 : &quot; + (user1 == user3)); System.out.println( &quot;user1 == user4 : &quot; + (user1 == user4)); System.out.println( &quot;user1 == user5 : &quot; + (user1 == user5)); //4.提交事务 t.commit(); //5.关闭资源 session.close();&#125; 2.2 运行结果12345678910111213Hibernate: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_ from tb_user2 user0_ where user0_.id=?user1 == user2 : trueuser1 == user3 : trueuser1 == user4 : trueuser1 == user5 : true 2.3 分析我们总共调用了 5 次 get 的方法，然而只执行了一次 数据库的查询操作。而且我们获取到的 5个对象都是同一个对象。这就是因为一级缓存的原因了。 2.3.1 一级缓存图示 image 2.3.2 一级缓存下查询分析 应用程序调用get查询id为1数据； hibernate先从缓存中查看是否存在id为1的User的对象。如果有，直接放回缓存中的对象，如果没有执行步骤3； hibernate发送sql到数据库中 数据库通过ResultSet放回结果到hibernate中； 如果ResultSet返回数据，那么hibernate把ResultSet中的数据组装成User对象； 把User对象存入到session缓存中； hibernate把缓存对象返回给应用程序。 三、快照快照其实就是一个存储了查询到的数据的集合。 3.1 代码实例1234567891011121314151617181920/** * 一级缓存测试二 快照 */@Testpublic void cacheTest2()&#123; //1.创建session Session session = HibernateUtils.openSession(); //2.开启事务 Transaction t = session.beginTransaction(); //3.查询对象 User user = session.get(User.class,1); System.out.println(&quot;查询到名称：&quot;+user.getName()); user.setName(&quot;wiming&quot;); user.setName(&quot;小明&quot;); //4.提交事务 t.commit(); //5.关闭资源 session.close();&#125; 3.2 运行结果12345678910Hibernate: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_ from tb_user2 user0_ where user0_.id=?查询到名称：小明 3.3 分析我们拿到的user是一个持久化状态的对象，它的所有改变都会同步到数据中。上面我们首先我们 查询到了 user 中的name是“小明”，然后我们设置了它的name为“wiming”,再然后我们又把name设置 回 “小明”，我们发现我们的这个修改不会同步到数据库。这就是快照的原因啦。 3.3.1 缓存和快照图示 image 3.3.2 缓存和快照下查询分析 应用程序调用get查询id为1数据； hibernate先从缓存中查看是否存在id为1的User的对象。如果有，直接放回缓存中的对象，如果没有执行步骤3； hibernate发送sql到数据库中 数据库通过ResultSet放回结果到hibernate中； 如果ResultSet返回数据，那么hibernate把ResultSet中的数据组装成User对象（会组装成为两个对象）； 组装成的这两个对象，一个放入到session缓存中，一个放入到快照中； hibernate把缓存对象返回给应用程序； 我们的应用程序修改了缓存中的对象； 应用程序向hibernate提交了事务， hibernate对比缓存中对象和快照。如果有变化就会同步到数据库中。 四、持久化状态对象其实就是放入session缓存中的对象4.1 代码实例123456789101112131415161718192021222324252627/** * 一级缓存测试三 * 持久化状态对象其实就是放入session缓存中的对象 */@Testpublic void cacheTest3()&#123; //1.创建session Session session = HibernateUtils.openSession(); //2.开启事务 Transaction t = session.beginTransaction(); //3.创建对象 User user = new User();//瞬时状态。没有id,没有添加到session缓存中 user.setId(1);//游离|托管状态 。有id,没有添加到session缓存中 session.update(user);// 游离|托管状态 -----&gt;持久化状态 // 获取id为1的对象 User user2 = session.get(User.class,1); System.out.println(&quot;user == user2 :&quot; + (user == user2)); System.out.println(&quot;---已经是持久化状态了，下面要执行的是commit了----&quot;); //4.提交事务 t.commit(); //5.关闭资源 session.close();&#125; 4.2 运行结果12345678910user == user2 :true---已经是持久化状态了，下面要执行的是commit了----Hibernate: update tb_user2 set name=?, age=? where id=? 4.3 分析上面我们可以看到，我们的user通过update从游离|托管状态 变成了 持久化状态， 然而这个时候是没有执行sql的。然后我们通过 session 的get方法，获取数据，也是没有执行sql 我们获取到了 user2 ,然后我们发现 user和user2是同一个对象。最后我们提交事务，这个时候才会 去执行更新的sql语句。 由分析我们可以得出 持久化状态对象其实就是放入session缓存中的对象。 五、提高效率的手段提高效率手段1:提高查询效率 如一级缓存。 提高效率手段2:减少不必要的修改语句发送 如快照","categories":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/categories/ssm/"},{"name":"hibernate","slug":"ssm/hibernate","permalink":"http://qiwenming.github.io/categories/ssm/hibernate/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/tags/ssm/"},{"name":"hibernate","slug":"hibernate","permalink":"http://qiwenming.github.io/tags/hibernate/"}]},{"title":"SSH与SSM学习之hibernate09——对象的三种状态","slug":"hibernate/09","date":"2017-11-19T13:52:00.000Z","updated":"2018-01-18T13:51:53.564Z","comments":false,"path":"hibernate/09/2017/11/19/","link":"","permalink":"http://qiwenming.github.io/hibernate/09/2017/11/19/","excerpt":"","text":"SSH与SSM学习之hibernate09——对象的三种状态一、对象的三种状态hibernate中，对象拥有三种状态：瞬时状态、持久化状态、游离|托管状态。 1.1 瞬时状态瞬时状态：没有id,没有在session缓存中。 例如下面的user实例就是 瞬时状态 123User user = new User();// 瞬时状态。没有id，没有与session 关联user.setName(&quot;xiaoming&quot;);// 瞬时状态。没有id，没有与session 关联user.setAge(19);// 瞬时状态。没有id，没有与session 关联 1.2 持久化状态持久化状态：有id,在session缓存中。 例如下面的user实例就是 瞬时状态 1session.save(user);//持久化状态。有id,与session关联 或 1User user = session.get(User.class,1);// 持久化状态。有id,与session关联 1.3 游离|托管状态游离|托管状态：有id,没有在session缓存中。 例如下面的user实例就是 瞬时状态 1234567891011User user = new User();// 瞬时状态。没有id，没有与session 关联user.setName(&quot;xiaoming&quot;);// 瞬时状态。没有id，没有与session 关联user.setAge(19);// 瞬时状态。没有id，没有与session 关联session.save(user);//持久化状态。有id,与session关联//--------------------------------------------//3.提交事务t.commit();//4.关闭资源session.close();//游离|托管状态。有id，没有与session关联 二、持久化状态对象的任何变化都会自动同步到数据库中例如下面的例子 12345678910111213141516171819202122232425262728/*三种状态特点 持久化状态特点: 持久化状态对象的任何变化都会自动同步到数据库中. */@Testpublic void statusDemo3()&#123; //1.获取Session Session session = HibernateUtils.openSession(); //2.开启事务 Transaction t = session.beginTransaction(); //------------------------------------------- User user = session.get(User.class,1);// 持久化状态。有id,与session关联 System.out.println(&quot;修改name属性前---&quot;+user); user.setName(&quot;杞文明&quot;);//持久化状态。有id,与session关联 user = session.get(User.class,1);// 持久化状态。有id,与session关联 System.out.println(&quot;修改name属性后---&quot;+user); //-------------------------------------------- //3.提交事务 t.commit(); //4.关闭资源 session.close();//游离|托管状态。有id，没有与session关联&#125; 打印结果 12修改name属性前---User&#123;id=1, name=&apos;xiaoming&apos;, age=19&#125;修改name属性后---User&#123;id=1, name=&apos;杞文明&apos;, age=19&#125; HibernateUtils.java 1234567891011121314151617181920212223242526272829303132333435363738package com.qwm.hibernate02;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.cfg.Configuration;/** * @author：qiwenming * @date：2017/9/17 0017 2:39 * @description： * Hibernate工具类 */public class HibernateUtils &#123; private static SessionFactory factory; static&#123; //1 创建,调用空参构造 Configuration conf = new Configuration().configure(); //2 根据配置信息,创建 SessionFactory对象 factory = conf.buildSessionFactory(); &#125; //获得session =&gt; 获得全新session public static Session openSession()&#123; //3 获得session Session session = factory.openSession(); return session; &#125; //获得session =&gt; 获得与线程绑定的session public static Session getCurrentSession()&#123; //3 获得session Session session = factory.getCurrentSession(); return session; &#125;&#125; 三、对象的三种状态转换 这里写图片描述","categories":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/categories/ssm/"},{"name":"hibernate","slug":"ssm/hibernate","permalink":"http://qiwenming.github.io/categories/ssm/hibernate/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/tags/ssm/"},{"name":"hibernate","slug":"hibernate","permalink":"http://qiwenming.github.io/tags/hibernate/"}]},{"title":"SSH与SSM学习之hibernate08——hibernate中的实体规则","slug":"hibernate/08","date":"2017-11-19T13:51:59.000Z","updated":"2018-01-18T13:51:53.562Z","comments":false,"path":"hibernate/08/2017/11/19/","link":"","permalink":"http://qiwenming.github.io/hibernate/08/2017/11/19/","excerpt":"","text":"SSH与SSM学习之hibernate08——hibernate中的实体规则一、实体类创建的注意事项 持久化类提供无参数构造 成员变量私有,提供共有get/set方法访问.需提供属性（JavaBean） 持久化类中的属性,应尽量使用包装类型 持久化类需要提供oid.与数据库中的主键列对应 不要用final修饰 class ( hibernate使用cglib代理生成代理对象.代理对象是继承被代理对象.如果被final修饰.将无法生成代理 ) 例如我们的User类就是满足上面条件的 User 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.qwm.hibernate02;/** * @author：qiwenming * @date：2017/9/17 0017 2:00 * @description： * User类 */public class User &#123; private Integer id; private String name; private Integer age; public User() &#123; &#125; public User(String name, Integer age) &#123; this.name = name; this.age = age; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; 二、主键类型2.1 自然主键(少见)表的业务列中,有某业务列符合,必须有,并且不重复的特征时,该列可以作为主键使用. 2.2 代理主键(常见)表的业务列中,没有某业务列符合,必须有,并且不重复的特征时,创建一个没有业务意义的列作为主键 三、主键生成策略3.1 代理主键 identity : 主键自增.由数据库来维护主键值.录入时不需要指定主键. sequence: Oracle中的主键生成策略. increment: 主键自增.由hibernate来维护.每次插入前会先查询表中id最大值.+1作为新主键值. hilo: 高低位算法.主键自增.由hibernate来维护.开发时不使用. native:hilo+sequence+identity 自动三选一策略. uuid: 产生随机字符串作为主键. 主键类型必须为string 类型. 例如我们的配置文件 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package=&quot;com.qwm.hibernate02&quot;&gt; &lt;class name=&quot;User&quot; table=&quot;tb_user2&quot;&gt; &lt;id name=&quot;id&quot;&gt; &lt;!--id自增--&gt; &lt;!-- generator:主键生成策略 --&gt; &lt;!-- generator:主键生成策略.就是每条记录录入时,主键的生成规则.(7个) identity : 主键自增.由数据库来维护主键值.录入时不需要指定主键. sequence: Oracle中的主键生成策略. increment: 主键自增.由hibernate来维护.每次插入前会先查询表中id最大值.+1作为新主键值. hilo: 高低位算法.主键自增.由hibernate来维护.开发时不使用. native: hilo+sequence+identity 自动三选一策略. uuid: 产生随机字符串作为主键. 主键类型必须为string 类型. assigned: 自然主键生成策略. hibernate不会管理主键值.由开发人员自己录入. --&gt; &lt;generator class=&quot;increment&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;name&quot;/&gt; &lt;property name=&quot;age&quot;/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 3.2 自然主键assigned:自然主键生成策略. hibernate不会管理主键值.由开发人员自己录入. 例如我们的配置文件 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package=&quot;com.qwm.hibernate02&quot;&gt; &lt;class name=&quot;User&quot; table=&quot;tb_user2&quot;&gt; &lt;id name=&quot;id&quot;&gt; &lt;generator class=&quot;assigned&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;name&quot;/&gt; &lt;property name=&quot;age&quot;/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt;","categories":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/categories/ssm/"},{"name":"hibernate","slug":"ssm/hibernate","permalink":"http://qiwenming.github.io/categories/ssm/hibernate/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/tags/ssm/"},{"name":"hibernate","slug":"hibernate","permalink":"http://qiwenming.github.io/tags/hibernate/"}]},{"title":"SSH与SSM学习之hibernate07——Transaction","slug":"hibernate/07","date":"2017-11-19T13:51:58.000Z","updated":"2018-01-18T13:51:53.561Z","comments":false,"path":"hibernate/07/2017/11/19/","link":"","permalink":"http://qiwenming.github.io/hibernate/07/2017/11/19/","excerpt":"","text":"SSH与SSM学习之hibernate07——Transaction一、TransactionTransaction 封装了事务的操作。 1.1 开启事务开启事务有两种方式，推荐第二种 方式一 12Transaction t = session.getTransaction();t.begin(); 方式二 1Transaction t = session.beginTransaction(); 1.2 提交事务1t.commit(); 1.3 回滚事务1t.rollback(); 二、提交事务实例2.1 代码1234567891011121314151617181920212223242526272829/** * 提交事务 */@Testpublic void commitDemo()&#123; // 1. 配置类型安全的准服务注册类，这是当前应用的单例对象，不作修改，所以声明为final final StandardServiceRegistry registry = new StandardServiceRegistryBuilder().configure(&quot;hibernate.cfg.xml&quot;).build(); // 2. 根据服务注册类创建一个元数据资源集，同时构建元数据并生成应用一般唯一的的session工厂 SessionFactory factory = new MetadataSources(registry).buildMetadata().buildSessionFactory(); //3 获取session Session session = factory.openSession(); //4 开启事务 Transaction t = session.beginTransaction(); //--------------------增加数据-------------------- User user = new User(&quot;qwm_commit&quot;,10); //5 保存数据 session.save(user); //或者使用 session.persist(user); //---------------------------------------- //6 提交事务 t.commit(); //7 关闭session session.close();&#125; 2.2 结果 image 三、回滚事务实例2.1 代码12345678910111213141516171819202122232425262728/** * 回滚事务 */@Testpublic void rollbackDemo()&#123; // 1. 配置类型安全的准服务注册类，这是当前应用的单例对象，不作修改，所以声明为final final StandardServiceRegistry registry = new StandardServiceRegistryBuilder().configure(&quot;hibernate.cfg.xml&quot;).build(); // 2. 根据服务注册类创建一个元数据资源集，同时构建元数据并生成应用一般唯一的的session工厂 SessionFactory factory = new MetadataSources(registry).buildMetadata().buildSessionFactory(); //3 获取session Session session = factory.openSession(); //4 开启事务 Transaction t = session.beginTransaction(); //--------------------增加数据-------------------- User user = new User(&quot;qwm_rollback&quot;,10); //5 保存数据 session.save(user); //或者使用 session.persist(user); //---------------------------------------- //6 回滚事务 t.rollback(); //7 关闭session session.close();&#125; 2.2 结果 image","categories":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/categories/ssm/"},{"name":"hibernate","slug":"ssm/hibernate","permalink":"http://qiwenming.github.io/categories/ssm/hibernate/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/tags/ssm/"},{"name":"hibernate","slug":"hibernate","permalink":"http://qiwenming.github.io/tags/hibernate/"}]},{"title":"SSH与SSM学习之hibernate06——Session","slug":"hibernate/06","date":"2017-11-19T13:51:57.000Z","updated":"2018-01-18T13:51:53.559Z","comments":false,"path":"hibernate/06/2017/11/19/","link":"","permalink":"http://qiwenming.github.io/hibernate/06/2017/11/19/","excerpt":"","text":"SSH与SSM学习之hibernate06——Session一、Sessionsession对象功能: 表达hibernate框架与数据库之间的连接(会话).session类似于JDBC年代的connection对象. 还可以完成对数据库中数据的增删改查操作. session是hibernate操作数据库的核心对象 数据的CRUD操作方法 12345Serializable save(Object object);//增void delete(Object object);//删除&lt;T&gt; T get(Class&lt;T&gt; entityType, Serializable id);//查询 二、Session对象的获取通过SessionFactory工厂来获取的12//3 获取sessionSession session = factory.openSession(); 如果你想要查看 里面是怎么操作的，那么需要查看 SessionFactoryImpl类，如下 SessionFactoryImpl 123456789101112131415161718192021222324252627282930313233public final class SessionFactoryImpl implements SessionFactoryImplementor &#123; ... public Session openSession() throws HibernateException &#123; return withOptions().openSession(); &#125; ... @Override public SessionBuilderImplementor withOptions() &#123; return new SessionBuilderImpl( this ); &#125; ... static class SessionBuilderImpl&lt;T extends SessionBuilder&gt; implements SessionBuilderImplementor&lt;T&gt;, SessionCreationOptions &#123; .... @Override public Session openSession() &#123; log.tracef( &quot;Opening Hibernate Session. tenant=%s, owner=%s&quot;, tenantIdentifier, sessionOwner ); final SessionImpl session = new SessionImpl( sessionFactory, this ); for ( SessionEventListener listener : listeners ) &#123; session.getEventListenerManager().addListener( listener ); &#125; return session; &#125; .... &#125; ...&#125; 三、Session添加数据12345678910111213141516171819202122232425262728/** * 添加数据 */@Testpublic void insert()&#123; // 1. 配置类型安全的准服务注册类，这是当前应用的单例对象，不作修改，所以声明为final final StandardServiceRegistry registry = new StandardServiceRegistryBuilder().configure(&quot;hibernate.cfg.xml&quot;).build(); // 2. 根据服务注册类创建一个元数据资源集，同时构建元数据并生成应用一般唯一的的session工厂 SessionFactory factory = new MetadataSources(registry).buildMetadata().buildSessionFactory(); //3 获取session Session session = factory.openSession(); //4 开启事务 Transaction t = session.beginTransaction(); //--------------------增加数据-------------------- User user = new User(&quot;qixiaoming&quot;,120); //5 保存数据 session.save(user); //或者使用 session.persist(user); //---------------------------------------- //6 提交事务 t.commit(); //7 关闭session session.close();&#125; 数据库表结果 这里写图片描述 四、Session查数据123456789101112131415161718192021222324252627/** * 查询数据 */@Testpublic void query()&#123; // 1. 配置类型安全的准服务注册类，这是当前应用的单例对象，不作修改，所以声明为final final StandardServiceRegistry registry = new StandardServiceRegistryBuilder().configure(&quot;hibernate.cfg.xml&quot;).build(); // 2. 根据服务注册类创建一个元数据资源集，同时构建元数据并生成应用一般唯一的的session工厂 SessionFactory factory = new MetadataSources(registry).buildMetadata().buildSessionFactory(); //3 获取session Session session = factory.openSession(); //4 开启事务 Transaction t = session.beginTransaction(); //--------------------查询数据-------------------- //5 查询数据 &lt;T&gt; T get(Class&lt;T&gt; entityType, Serializable id); User user = session.get(User.class,6); System.out.println(user); //---------------------------------------- //6 提交事务 t.commit(); //7 关闭session session.close();&#125; 结果1User&#123;id=6, name=&apos;qixiaoming&apos;, age=120&#125; 五、Session修改数据12345678910111213141516171819202122232425262728/** * 修改数据 */@Testpublic void update()&#123; // 1. 配置类型安全的准服务注册类，这是当前应用的单例对象，不作修改，所以声明为final final StandardServiceRegistry registry = new StandardServiceRegistryBuilder().configure(&quot;hibernate.cfg.xml&quot;).build(); // 2. 根据服务注册类创建一个元数据资源集，同时构建元数据并生成应用一般唯一的的session工厂 SessionFactory factory = new MetadataSources(registry).buildMetadata().buildSessionFactory(); //3 获取session Session session = factory.openSession(); //4 开启事务 Transaction t = session.beginTransaction(); //--------------------修改数据-------------------- //5 查询数据 &lt;T&gt; T get(Class&lt;T&gt; entityType, Serializable id); User user = session.get(User.class,6); //修改数据 user.setName(&quot;杞文明&quot;); //---------------------------------------- //6 提交事务 t.commit(); //7 关闭session session.close();&#125; 数据库表结果 这里写图片描述 六、Session删除数据12345678910111213141516171819202122232425262728/** * 删除数据 */@Testpublic void delete()&#123; // 1. 配置类型安全的准服务注册类，这是当前应用的单例对象，不作修改，所以声明为final final StandardServiceRegistry registry = new StandardServiceRegistryBuilder().configure(&quot;hibernate.cfg.xml&quot;).build(); // 2. 根据服务注册类创建一个元数据资源集，同时构建元数据并生成应用一般唯一的的session工厂 SessionFactory factory = new MetadataSources(registry).buildMetadata().buildSessionFactory(); //3 获取session Session session = factory.openSession(); //4 开启事务 Transaction t = session.beginTransaction(); //--------------------删除数据-------------------- //5 查询数据 &lt;T&gt; T get(Class&lt;T&gt; entityType, Serializable id); User user = session.get(User.class,6); // 删除数据 session.delete(user); //---------------------------------------- //6 提交事务 t.commit(); //7 关闭session session.close();&#125; 数据库表结果 这里写图片描述","categories":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/categories/ssm/"},{"name":"hibernate","slug":"ssm/hibernate","permalink":"http://qiwenming.github.io/categories/ssm/hibernate/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/tags/ssm/"},{"name":"hibernate","slug":"hibernate","permalink":"http://qiwenming.github.io/tags/hibernate/"}]},{"title":"SSH与SSM学习之hibernate05——SessionFactory","slug":"hibernate/05","date":"2017-11-19T13:51:56.000Z","updated":"2018-01-18T13:51:53.558Z","comments":false,"path":"hibernate/05/2017/11/19/","link":"","permalink":"http://qiwenming.github.io/hibernate/05/2017/11/19/","excerpt":"","text":"SSH与SSM学习之hibernate05——SessionFactory一、SessionFactory说明SessionFactory功能: 用于创建操作数据库核心对象session对象的工厂. 简单说功能就一个—创建session对象 注意: 1.sessionfactory 负责保存和使用所有配置信息.消耗内存资源非常大. 2.sessionFactory属于线程安全的对象设计. 结论: 保证在web项目中,只创建一个sessionFactory. 二、两种获取方式2.1 方式一12345678910//Configuration功能: 配置加载类.用于加载主配置,orm元数据加载//1 创建Configuration,调用空构造方法Configuration conf = new Configuration();//2 读取指定主配置文件 =&gt; 空参加载方法,加载src下的hibernate.cfg.xml文件conf.configure();//或者调用如下的方法,与上面是一样的//sconf.configure(&quot;hibernate.cfg.xml&quot;);//如果我们主配置文件是在com下面，那么应该是 conf.configure(&quot;com/hibernate.cfg.xml&quot;);//3 根据配置信息，创建 SessionFactory 对象SessionFactory factory = conf.buildSessionFactory(); 2.2 方式二1234567// 但在5.1.0版本汇总，hibernate则采用如下新方式获取：// 1. 配置类型安全的准服务注册类，这是当前应用的单例对象，不作修改，所以声明为final// 在configure(&quot;hibernate.cfg.xml&quot;)方法中，如果不指定资源路径，默认在类路径下寻找名为hibernate.cfg.xml的文件final StandardServiceRegistry registry = new StandardServiceRegistryBuilder().configure(&quot;hibernate.cfg.xml&quot;).build();// 2. 根据服务注册类创建一个元数据资源集，同时构建元数据并生成应用一般唯一的的session工厂SessionFactory factory = new MetadataSources(registry).buildMetadata().buildSessionFactory(); 三、例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package com.qwm.hilbernate01;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.boot.MetadataSources;import org.hibernate.boot.registry.StandardServiceRegistry;import org.hibernate.boot.registry.StandardServiceRegistryBuilder;import org.hibernate.cfg.Configuration;import org.junit.Test;/** * @author：qiwenming * @date：2017/9/16 0016 22:09 * @description： */public class ApiDemo2 &#123;/*SessionFactory功能: 用于创建操作数据库核心对象session对象的工厂. 简单说功能就一个---创建session对象注意: 1.sessionfactory 负责保存和使用所有配置信息.消耗内存资源非常大. 2.sessionFactory属于线程安全的对象设计.结论: 保证在web项目中,只创建一个sessionFactory.*/ @Test public void sfApiDeme1()&#123; //Configuration功能: 配置加载类.用于加载主配置,orm元数据加载 //1 创建Configuration,调用空构造方法 Configuration conf = new Configuration(); //2 读取指定主配置文件 =&gt; 空参加载方法,加载src下的hibernate.cfg.xml文件 conf.configure(); //或者调用如下的方法,与上面是一样的 //sconf.configure(&quot;hibernate.cfg.xml&quot;); //如果我们主配置文件是在com下面，那么应该是 conf.configure(&quot;com/hibernate.cfg.xml&quot;); //3 根据配置信息，创建 SessionFactory 对象 SessionFactory factory = conf.buildSessionFactory(); //4 获取session Session session = factory.openSession(); //5 开启事务 Transaction t = session.beginTransaction(); User user = new User(&quot;mingge&quot;,12); //6 数据持久化 session.persist(user); //7 提交事务 t.commit(); //8 关闭session session.close(); &#125; @Test public void sfApiDemo2()&#123; // 但在5.1.0版本汇总，hibernate则采用如下新方式获取： // 1. 配置类型安全的准服务注册类，这是当前应用的单例对象，不作修改，所以声明为final // 在configure(&quot;hibernate.cfg.xml&quot;)方法中，如果不指定资源路径，默认在类路径下寻找名为hibernate.cfg.xml的文件 final StandardServiceRegistry registry = new StandardServiceRegistryBuilder().configure(&quot;hibernate.cfg.xml&quot;).build(); // 2. 根据服务注册类创建一个元数据资源集，同时构建元数据并生成应用一般唯一的的session工厂 SessionFactory factory = new MetadataSources(registry).buildMetadata().buildSessionFactory(); //3 获取session Session session = factory.openSession(); //4 开启事务 Transaction t = session.beginTransaction(); User user = new User(&quot;yy&quot;,20); //5 数据持久化 session.persist(user); //6 提交事务 t.commit(); //7 关闭session session.close(); &#125;&#125; 四、数据库表结果 这里写图片描述","categories":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/categories/ssm/"},{"name":"hibernate","slug":"ssm/hibernate","permalink":"http://qiwenming.github.io/categories/ssm/hibernate/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/tags/ssm/"},{"name":"hibernate","slug":"hibernate","permalink":"http://qiwenming.github.io/tags/hibernate/"}]},{"title":"SSH与SSM学习之hibernate04——Configuration","slug":"hibernate/04","date":"2017-11-19T13:51:55.000Z","updated":"2018-01-18T13:51:53.557Z","comments":false,"path":"hibernate/04/2017/11/19/","link":"","permalink":"http://qiwenming.github.io/hibernate/04/2017/11/19/","excerpt":"","text":"SSH与SSM学习之hibernate04——Configuration一、Configuration主要方法说明Configuration功能: 配置加载类.用于加载主配置,orm元数据加载 我们主要用到以下的方法 12345678configure()configure(String resource)Configuration configure(URL url)Configuration configure(File configFile) 都是加载配置的，我们主要看一下我们最常用的两个 123configure()configure(String resource) 查看我们的源码，是这定义的 Configuration 1234567891011121314....public Configuration configure() throws HibernateException &#123; return configure( StandardServiceRegistryBuilder.DEFAULT_CFG_RESOURCE_NAME );&#125;public Configuration configure(String resource) throws HibernateException &#123; standardServiceRegistryBuilder.configure( resource ); // todo : still need to have StandardServiceRegistryBuilder handle the &quot;other cfg.xml&quot; elements. // currently it just reads the config properties properties.putAll( standardServiceRegistryBuilder.getSettings() ); return this;&#125;.... DEFAULT_CFG_RESOURCE_NAME值 123456789public class StandardServiceRegistryBuilder &#123; /** * The default resource name for a hibernate configuration xml file. */ public static final String DEFAULT_CFG_RESOURCE_NAME = &quot;hibernate.cfg.xml&quot;; ..... &#125; 所以如果我们的配置文件 hibernate.cfg.xml 在 src下，那么我们下面的两种方式是一样的 12345//下面的两行代码是一样的conf.configure();conf.configure(&quot;hibernate.cfg.xml&quot;); 我们的主配置文件绝大多数都是放在src 下的，所以一般都是上面两种方式加载配置的。 如果你放在 src其他目录下,需要写相对于 src下的相对位置。比如我现在的配置文件是在src/com下，那么我的添加配置应该如下 1conf.configure(&quot;com/hibernate.cfg.xml&quot;); 二、Configuration例子123456789101112131415161718192021222324252627282930/** * Configuration 配置一 */@Testpublic void configurationDemo1()&#123; //Configuration功能: 配置加载类.用于加载主配置,orm元数据加载 //1 创建Configuration,调用空构造方法 Configuration conf = new Configuration(); //2 读取指定主配置文件 =&gt; 空参加载方法,加载src下的hibernate.cfg.xml文件 conf.configure(); //或者调用如下的方法,与上面是一样的 //sconf.configure(&quot;hibernate.cfg.xml&quot;); //如果我们主配置文件是在com下面，那么应该是 conf.configure(&quot;com/hibernate.cfg.xml&quot;); //3 根据配置信息，创建 SessionFactory 对象 SessionFactory factory = conf.buildSessionFactory(); //4 获取session Session session = factory.openSession(); //5 开启事务 Transaction t = session.beginTransaction(); User user = new User(&quot;xiaoming&quot;,18); //6 数据持久化 session.persist(user); //7 提交事务 t.commit(); //8 关闭session session.close();&#125; 三、推荐使StandardServiceRegistry1234567891011121314151617181920212223@Testpublic void configurationDemo2()&#123; // 但在5.1.0版本汇总，hibernate则采用如下新方式获取： // 1. 配置类型安全的准服务注册类，这是当前应用的单例对象，不作修改，所以声明为final // 在configure(&quot;hibernate.cfg.xml&quot;)方法中，如果不指定资源路径，默认在类路径下寻找名为hibernate.cfg.xml的文件 final StandardServiceRegistry registry = new StandardServiceRegistryBuilder().configure(&quot;hibernate.cfg.xml&quot;).build(); // 2. 根据服务注册类创建一个元数据资源集，同时构建元数据并生成应用一般唯一的的session工厂 SessionFactory factory = new MetadataSources(registry).buildMetadata().buildSessionFactory(); //3 获取session Session session = factory.openSession(); //4 开启事务 Transaction t = session.beginTransaction(); User user = new User(&quot;mingming&quot;,20); //5 数据持久化 session.persist(user); //6 提交事务 t.commit(); //7 关闭session session.close();&#125; 四、数据库中的结果 这里写图片描述","categories":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/categories/ssm/"},{"name":"hibernate","slug":"ssm/hibernate","permalink":"http://qiwenming.github.io/categories/ssm/hibernate/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/tags/ssm/"},{"name":"hibernate","slug":"hibernate","permalink":"http://qiwenming.github.io/tags/hibernate/"}]},{"title":"SSH与SSM学习之hibernate03——主配置详解","slug":"hibernate/03","date":"2017-11-19T13:51:54.000Z","updated":"2018-01-18T13:51:53.555Z","comments":false,"path":"hibernate/03/2017/11/19/","link":"","permalink":"http://qiwenming.github.io/hibernate/03/2017/11/19/","excerpt":"","text":"SSH与SSM学习之hibernate03——主配置详解一、配置相关的文件获取我们下载包以后解压可以去下面这个位置找到全部配置相关的文件 1project\\etc 有如下的配置文件 123456ehcache.xml (二级缓存配置)hibernate.cfg.xml (hibernate的主配置文件)hibernate.properties (这里可以找到主配置文件中，能够配置的选项)hibernate.properties.templatehibernate-service.xmllog4j.properties (日志配置) 二、我们的主配置文件1234567891011121314151617181920212223&lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!--数据库驱动--&gt; &lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;!--数据库url--&gt; &lt;property name=&quot;hibernate.connection.url&quot;&gt;jdbc:mysql://localhost:3306/htest&lt;/property&gt; &lt;!--数据库连接用户名--&gt; &lt;property name=&quot;hibernate.connection.username&quot;&gt;root&lt;/property&gt; &lt;!--数据库连接密码--&gt; &lt;property name=&quot;hibernate.connection.password&quot;&gt;xm123456&lt;/property&gt; &lt;!--数据库方言--&gt; &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL5Dialect&lt;/property&gt; &lt;!--自动创建表--&gt; &lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/property&gt; &lt;!--导入 User 配置--&gt; &lt;mapping resource=&quot;com/qwm/hilbernate01/user.hbm.xml&quot;/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 三、必选属性配置(5个)12345678910111213141516 &lt;!--数据库驱动--&gt; &lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;!--数据库url--&gt; &lt;property name=&quot;hibernate.connection.url&quot;&gt;jdbc:mysql://localhost:3306/htest&lt;/property&gt; &lt;!--数据库连接用户名--&gt; &lt;property name=&quot;hibernate.connection.username&quot;&gt;root&lt;/property&gt; &lt;!--数据库连接密码--&gt; &lt;property name=&quot;hibernate.connection.password&quot;&gt;xm123456&lt;/property&gt; &lt;!--数据库方言--&gt; &lt;!-- 数据库方言不同的数据库中,sql语法略有区别. 指定方言可以让hibernate框架在生成sql语句时.针对数据库的方言生成.sql99标准: DDL 定义语言 库表的增删改查 DCL 控制语言 事务 权限 DML 操纵语言 增删改查--&gt; &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL5Dialect&lt;/property&gt; 四、可选属性配置(3个)12345678910111213&lt;!-- 将hibernate生成的sql语句打印到控制台 --&gt;&lt;property name=&quot;hibernate.show_sql&quot;&gt;true&lt;/property&gt;&lt;!-- 将hibernate生成的sql语句格式化(语法缩进) --&gt;&lt;property name=&quot;hibernate.format_sql&quot;&gt;true&lt;/property&gt;&lt;!-- ## auto schema export 自动导出表结构. 自动建表#hibernate.hbm2ddl.auto create 自动建表.每次框架运行都会创建新的表.以前表将会被覆盖,表数据会丢失.(开发环境中测试使用)#hibernate.hbm2ddl.auto create-drop 自动建表.每次框架运行结束都会将所有表删除.(开发环境中测试使用)#hibernate.hbm2ddl.auto update(推荐使用) 自动生成表.如果已经存在不会再生成.如果表有变动.自动更新表(不会删除任何数据).#hibernate.hbm2ddl.auto validate 校验.不自动生成表.每次启动会校验数据库中表是否正确.校验失败. --&gt;&lt;!--自动创建表--&gt;&lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/property&gt; 五、元数据引入配置123456&lt;!--导入 User 配置--&gt;&lt;!-- 引入orm元数据 路径书写: 填写src下的路径 --&gt;&lt;mapping resource=&quot;com/qwm/hilbernate01/user.hbm.xml&quot;/&gt; 六、全部的标注12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!--数据库驱动--&gt; &lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;!--数据库url--&gt; &lt;property name=&quot;hibernate.connection.url&quot;&gt;jdbc:mysql://localhost:3306/htest&lt;/property&gt; &lt;!--数据库连接用户名--&gt; &lt;property name=&quot;hibernate.connection.username&quot;&gt;root&lt;/property&gt; &lt;!--数据库连接密码--&gt; &lt;property name=&quot;hibernate.connection.password&quot;&gt;xm123456&lt;/property&gt; &lt;!--数据库方言--&gt; &lt;!-- 数据库方言 不同的数据库中,sql语法略有区别. 指定方言可以让hibernate框架在生成sql语句时.针对数据库的方言生成. sql99标准: DDL 定义语言 库表的增删改查 DCL 控制语言 事务 权限 DML 操纵语言 增删改查 --&gt; &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL5Dialect&lt;/property&gt; &lt;!-- #hibernate.show_sql true #hibernate.format_sql true--&gt; &lt;!-- 将hibernate生成的sql语句打印到控制台 --&gt; &lt;property name=&quot;hibernate.show_sql&quot;&gt;true&lt;/property&gt; &lt;!-- 将hibernate生成的sql语句格式化(语法缩进) --&gt; &lt;property name=&quot;hibernate.format_sql&quot;&gt;true&lt;/property&gt; &lt;!-- ## auto schema export 自动导出表结构. 自动建表 #hibernate.hbm2ddl.auto create 自动建表.每次框架运行都会创建新的表.以前表将会被覆盖,表数据会丢失.(开发环境中测试使用) #hibernate.hbm2ddl.auto create-drop 自动建表.每次框架运行结束都会将所有表删除.(开发环境中测试使用) #hibernate.hbm2ddl.auto update(推荐使用) 自动生成表.如果已经存在不会再生成.如果表有变动.自动更新表(不会删除任何数据). #hibernate.hbm2ddl.auto validate 校验.不自动生成表.每次启动会校验数据库中表是否正确.校验失败. --&gt; &lt;!--自动创建表--&gt; &lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/property&gt; &lt;!--导入 User 配置--&gt; &lt;!-- 引入orm元数据 路径书写: 填写src下的路径 --&gt; &lt;mapping resource=&quot;com/qwm/hilbernate01/user.hbm.xml&quot;/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt;","categories":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/categories/ssm/"},{"name":"hibernate","slug":"ssm/hibernate","permalink":"http://qiwenming.github.io/categories/ssm/hibernate/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/tags/ssm/"},{"name":"hibernate","slug":"hibernate","permalink":"http://qiwenming.github.io/tags/hibernate/"}]},{"title":"SSH与SSM学习之hibernate02——ORM配置详解","slug":"hibernate/02","date":"2017-11-19T13:51:53.000Z","updated":"2018-01-18T13:51:53.554Z","comments":false,"path":"hibernate/02/2017/11/19/","link":"","permalink":"http://qiwenming.github.io/hibernate/02/2017/11/19/","excerpt":"","text":"SSH与SSM学习之hibernate02——ORM配置详解一、我们的ORM配置文件1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping&gt; &lt;class name=&quot;com.qwm.hilbernate01.User&quot;&gt; &lt;id name=&quot;id&quot;&gt; &lt;!--id自增--&gt; &lt;generator class=&quot;increment&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;name&quot;/&gt; &lt;property name=&quot;age&quot;/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 二、根元素12345&lt;!-- 配置表与实体对象的关系 --&gt;&lt;!-- package属性:填写一个包名.在元素内部凡是需要书写完整类名的属性,可以直接写简答类名了. --&gt;&lt;hibernate-mapping package=&quot;com.qwm.hilbernate01&quot;&gt;....&lt;/hibernate-mapping&gt; 原来的配置文件就可以改为 123456789....&lt;!-- 配置表与实体对象的关系 --&gt;&lt;!-- package属性:填写一个包名.在元素内部凡是需要书写完整类名的属性,可以直接写简答类名了. --&gt;&lt;hibernate-mapping package=&quot;com.qwm.hilbernate01&quot;&gt; &lt;class name=&quot;User&quot;&gt; ..... &lt;/class&gt;&lt;/hibernate-mapping&gt; 三、class元素12345678&lt;!-- class元素: 配置实体与表的对应关系的 name: 完整类名 table:数据库表名 --&gt;&lt;class name=&quot;User&quot; table=&quot;tb_user1&quot;&gt;....&lt;/class&gt; 四、id元素1234567891011121314&lt;!-- id元素:配置主键映射的属性 name: 填写主键对应属性名(类中的属性) column(可选): 填写表中的主键列名.默认值:列名会默认使用属性名 type(可选):填写列(属性)的类型.hibernate会自动检测实体的属性类型. 每个类型有三种填法: java类型|hibernate类型|数据库类型 not-null(可选):配置该属性(列)是否不能为空. 默认值:false length(可选):配置数据库中列的长度. 默认值:使用数据库类型的最大长度 --&gt;&lt;id name=&quot;id&quot;&gt; &lt;!--id自增--&gt; &lt;!-- generator:主键生成策略 --&gt; &lt;generator class=&quot;increment&quot;&gt;&lt;/generator&gt;&lt;/id&gt; 五、主键生成策略1234567891011121314151617181920212223&lt;!-- id元素:配置主键映射的属性 name: 填写主键对应属性名(类中的属性) column(可选): 填写表中的主键列名.默认值:列名会默认使用属性名 type(可选):填写列(属性)的类型.hibernate会自动检测实体的属性类型. 每个类型有三种填法: java类型|hibernate类型|数据库类型 not-null(可选):配置该属性(列)是否不能为空. 默认值:false length(可选):配置数据库中列的长度. 默认值:使用数据库类型的最大长度 --&gt;&lt;id name=&quot;id&quot;&gt; &lt;!--id自增--&gt; &lt;!-- generator:主键生成策略 --&gt; &lt;!-- generator:主键生成策略.就是每条记录录入时,主键的生成规则.(7个) identity : 主键自增.由数据库来维护主键值.录入时不需要指定主键. sequence: Oracle中的主键生成策略. increment: 主键自增.由hibernate来维护.每次插入前会先查询表中id最大值.+1作为新主键值. hilo: 高低位算法.主键自增.由hibernate来维护.开发时不使用. native: hilo+sequence+identity 自动三选一策略. uuid: 产生随机字符串作为主键. 主键类型必须为string 类型. assigned: 自然主键生成策略. hibernate不会管理主键值.由开发人员自己录入. --&gt; &lt;generator class=&quot;increment&quot;&gt;&lt;/generator&gt;&lt;/id&gt; 六、property元素12345678910&lt;!-- property元素:除id之外的普通属性映射 name: 填写属性名 column(可选): 填写列名 type(可选):填写列(属性)的类型.hibernate会自动检测实体的属性类型. 每个类型有三种填法: java类型|hibernate类型|数据库类型 not-null(可选):配置该属性(列)是否不能为空. 默认值:false length(可选):配置数据库中列的长度. 默认值:使用数据库类型的最大长度--&gt;&lt;property name=&quot;name&quot;/&gt; 七、完整的配置说明12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;!-- 配置表与实体对象的关系 --&gt;&lt;!-- package属性:填写一个包名.在元素内部凡是需要书写完整类名的属性,可以直接写简答类名了. --&gt;&lt;hibernate-mapping package=&quot;com.qwm.hilbernate01&quot;&gt; &lt;!-- class元素: 配置实体与表的对应关系的 name: 完整类名 table:数据库表名 --&gt; &lt;class name=&quot;User&quot; table=&quot;tb_user1&quot;&gt; &lt;!-- id元素:配置主键映射的属性 name: 填写主键对应属性名(类中的属性) column(可选): 填写表中的主键列名.默认值:列名会默认使用属性名 type(可选):填写列(属性)的类型.hibernate会自动检测实体的属性类型. 每个类型有三种填法: java类型|hibernate类型|数据库类型 not-null(可选):配置该属性(列)是否不能为空. 默认值:false length(可选):配置数据库中列的长度. 默认值:使用数据库类型的最大长度 --&gt; &lt;id name=&quot;id&quot;&gt; &lt;!--id自增--&gt; &lt;!-- generator:主键生成策略 --&gt; &lt;!-- generator:主键生成策略.就是每条记录录入时,主键的生成规则.(7个) identity : 主键自增.由数据库来维护主键值.录入时不需要指定主键. sequence: Oracle中的主键生成策略. increment: 主键自增.由hibernate来维护.每次插入前会先查询表中id最大值.+1作为新主键值. hilo: 高低位算法.主键自增.由hibernate来维护.开发时不使用. native: hilo+sequence+identity 自动三选一策略. uuid: 产生随机字符串作为主键. 主键类型必须为string 类型. assigned: 自然主键生成策略. hibernate不会管理主键值.由开发人员自己录入. --&gt; &lt;generator class=&quot;increment&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;!-- property元素:除id之外的普通属性映射 name: 填写属性名 column(可选): 填写列名 type(可选):填写列(属性)的类型.hibernate会自动检测实体的属性类型. 每个类型有三种填法: java类型|hibernate类型|数据库类型 not-null(可选):配置该属性(列)是否不能为空. 默认值:false length(可选):配置数据库中列的长度. 默认值:使用数据库类型的最大长度 --&gt; &lt;property name=&quot;name&quot;/&gt; &lt;property name=&quot;age&quot;/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt;","categories":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/categories/ssm/"},{"name":"hibernate","slug":"ssm/hibernate","permalink":"http://qiwenming.github.io/categories/ssm/hibernate/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/tags/ssm/"},{"name":"hibernate","slug":"hibernate","permalink":"http://qiwenming.github.io/tags/hibernate/"}]},{"title":"SSH与SSM学习之hibernate02——ORM配置详解","slug":"hibernate/01","date":"2017-11-19T13:51:50.000Z","updated":"2018-01-18T13:52:41.291Z","comments":false,"path":"hibernate/01/2017/11/19/","link":"","permalink":"http://qiwenming.github.io/hibernate/01/2017/11/19/","excerpt":"","text":"SSH与SSM学习之hibernate01——介绍与环境搭建一、hibernate介绍Hibernate 是一个高性能的对象关系型持久化存储和查询的服务，其遵循开源的 GNU Lesser General Public License (LGPL) 而且可以免费下载。Hibernate 不仅关注于从 Java 类到数据库表的映射，也有 Java 数据类型到 SQL 数据类型的映射，另外也提供了数据查询和检索服务。这个教程将指导你如何以简单的方式使用 Hibernate 来开发基于数据库的 Web 应用程序。 二、所需环境2.1 开发工具我们需要使用这个框架，需要自己有开发工具，如：eclipse、idea 等。我使用的是idea。下载地址如下 https://www.jetbrains.com/idea/ 2.2 数据库既然是操作数据库的，那么我们应该需要数据库吧。你可以使用 MS SQLServer、Oracle、MySql。我使用的是 MySql. MySql 下载地址 https://dev.mysql.com/downloads/windows/ 2.3 hibernate既然我们要学习 hibernate ,那么它必须不能少、 hibernate下载地址 http://hibernate.org/orm/downloads/ 2.4 junit（非必须）这个单元测试的包，我们是用来写代码的时候测试用的。为了我们测试方便，加上这个包，非必须。使用junit.jar还需需要导入 hamcrest-core.jar 三、项目的基本配置你也可以不用我的方式创建，可以按网上的创建 使用Intellij IEDA创建第一个hibernate例子 3.1 创建项目 这里写图片描述 3.2 填写项目名称 这里写图片描述 3.3 创建classes和lib目录 这里写图片描述 3. 4 导入hibernate包 这里写图片描述 3. 5 打开当前项目的配置 这里写图片描述 3. 6 创建项目的lib 这里写图片描述 3. 7 选择jar包 这里写图片描述 这里写图片描述 3. 8 修改添加以后的 libraries 名字 这里写图片描述 3. 9 配置 .class 的输出路径 这里写图片描述 3. 10 添加lib的依赖 这里写图片描述 3. 11 点击配置 这里写图片描述 3. 12 添加Tomcat 这里写图片描述 3. 13 更改名称 这里写图片描述 3. 14 添加 Artifacts 这里写图片描述 3. 15 更改访问路径 这里写图片描述 四、Hibernate的基本配置上面的步骤，基本完成了我们配置，那么现在我们来搞一把，hibernate。 4.1 创建我们的包在src 下创建我们的包 com.qwm.hilbernate01 4.2 创建 User类在com.qwm.hilbernate01包下，创建 User类，如下（如果你自己定义了构造方法，必须添加为空构造方法） 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.qwm.hilbernate01;/** * @author：qiwenming * @date：2017/9/16 0016 19:19 * @description： * User类 */public class User &#123; private int id; private String name; private int age; public User() &#123; &#125; public User(String name, int age) &#123; this.name = name; this.age = age; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 4.3 创建 user.hbm.xml在com.qwm.hilbernate01包下，创建文件 user.hbm.xml，配置如下 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping&gt; &lt;class name=&quot;com.qwm.hilbernate01.User&quot;&gt; &lt;id name=&quot;id&quot;&gt; &lt;!--id自增--&gt; &lt;generator class=&quot;increment&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;name&quot;/&gt; &lt;property name=&quot;age&quot;/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 4.4 创建 hibernate.cfg.xml在 src 下创建 hibernate.cfg.xml 文件，如下 1234567891011121314151617181920212223&lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!--MySql数据库驱动--&gt; &lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;!--数据库--&gt; &lt;property name=&quot;hibernate.connection.url&quot;&gt;jdbc:mysql://localhost:3306/htest&lt;/property&gt; &lt;!--用户名--&gt; &lt;property name=&quot;hibernate.connection.username&quot;&gt;root&lt;/property&gt; &lt;!--密码--&gt; &lt;property name=&quot;hibernate.connection.password&quot;&gt;xm123456&lt;/property&gt; &lt;!--数据库方言--&gt; &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL5Dialect&lt;/property&gt; &lt;!--自动创建表--&gt; &lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/property&gt; &lt;!--导入 User 配置--&gt; &lt;mapping resource=&quot;com/qwm/hilbernate01/user.hbm.xml&quot;/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 4.5 导入Junit包如果使用Junit测试，如要添加如下包 123junit.jarhamcrest-core.jar 4.6 创建HelloTest类在com.qwm.hilbernate01包下，创建类 HelloTest.java，测试我们的hibernate123456789101112131415161718192021222324252627282930313233343536373839package com.qwm.hilbernate01;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.boot.MetadataSources;import org.hibernate.boot.registry.StandardServiceRegistry;import org.hibernate.boot.registry.StandardServiceRegistryBuilder;import org.junit.Test;/** * 测试一 */public class HelloTest &#123; /** * 测试一 */ @Test public void testUser1()&#123; // 1.配置 StandardServiceRegistry registry = new StandardServiceRegistryBuilder().configure(&quot;hibernate.cfg.xml&quot;).build(); // 2. 获取Session 工厂 SessionFactory factory = new MetadataSources(registry).buildMetadata().buildSessionFactory(); // 3. 打开Session Session session = factory.openSession(); // 4. 开启事物 Transaction t = session.beginTransaction(); // 5. 创建对象 User user = new User(&quot;wiming&quot;,19); // 6. 对象持久化 session.persist(user); // 7. 提交事务 t.commit(); // 8. 关闭Session session.close(); System.out.println(&quot;创建成功&quot;); &#125;&#125; 4.7 查看我们的数据库的表如下 这里写图片描述","categories":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/categories/ssm/"},{"name":"hibernate","slug":"ssm/hibernate","permalink":"http://qiwenming.github.io/categories/ssm/hibernate/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://qiwenming.github.io/tags/ssm/"},{"name":"hibernate","slug":"hibernate","permalink":"http://qiwenming.github.io/tags/hibernate/"}]}]}